/*
 * $Id: a67fd64ccaf74da10379a2a487b3059089a1e04a $
 *
 * This file is part of the iText (R) project.
 * Copyright (c) 2014-2015 iText Group NV
 * Authors: Bruno Lowagie, Paulo Soares, et al.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License version 3
 * as published by the Free Software Foundation with the addition of the
 * following permission added to Section 15 as permitted in Section 7(a):
 * FOR ANY PART OF THE COVERED WORK IN WHICH THE COPYRIGHT IS OWNED BY
 * ITEXT GROUP. ITEXT GROUP DISCLAIMS THE WARRANTY OF NON INFRINGEMENT
 * OF THIRD PARTY RIGHTS
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, see http://www.gnu.org/licenses or write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA, 02110-1301 USA, or download the license from the following URL:
 * http://itextpdf.com/terms-of-use/
 *
 * The interactive user interfaces in modified source and object code versions
 * of this program must display Appropriate Legal Notices, as required under
 * Section 5 of the GNU Affero General Public License.
 *
 * In accordance with Section 7(b) of the GNU Affero General Public License,
 * a covered work must retain the producer line in every PDF that is created
 * or manipulated using iText.
 *
 * You can be released from the requirements of the license by purchasing
 * a commercial license. Buying such a license is mandatory as soon as you
 * develop commercial activities involving the iText software without
 * disclosing the source code of your own applications.
 * These activities include: offering paid services to customers as an ASP,
 * serving PDFs on the fly in a web application, shipping iText with a closed
 * source product.
 *
 * For more information, please contact iText Software Corp. at this
 * address: sales@itextpdf.com
 *
 *
 * This class is based on the C# open source freeware library Clipper:
 * http://www.angusj.com/delphi/clipper.php
 * The original classes were distributed under the Boost Software License:
 *
 * Freeware for both open source and commercial applications
 * Copyright 2010-2014 Angus Johnson
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
package com.itextpdf.text.pdf.parser.clipper

import com.itextpdf.text.pdf.parser.clipper.Path.Join
import com.itextpdf.text.pdf.parser.clipper.Path.OutRec
import com.itextpdf.text.pdf.parser.clipper.Point.LongPoint

import java.util.ArrayList
import java.util.Collections
import java.util.Comparator
import java.util.logging.Logger

class DefaultClipper @JvmOverloads constructor(InitOptions: Int = 0 //constructor
) : ClipperBase(Clipper.PRESERVE_COLINEAR and InitOptions != 0) {
    private inner class IntersectNode {
        internal var edge1: Edge
        internal var Edge2: Edge
        var pt: LongPoint? = null

    }

    private fun joinPoints(j: Join, outRec1: OutRec, outRec2: OutRec): Boolean {
        var op1 = j.outPt1
        var op1b: Path.OutPt
        var op2 = j.outPt2
        var op2b: Path.OutPt

        //There are 3 kinds of joins for output polygons ...
        //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere
        //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).
        //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same
        //location at the Bottom of the overlapping segment (& Join.OffPt is above).
        //3. StrictlySimple joins where edges touch but are not collinear and where
        //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.
        val isHorizontal = j.outPt1.pt.y == j.offPt.y

        if (isHorizontal && j.offPt == j.outPt1.pt && j.offPt == j.outPt2.pt) {
            //Strictly Simple join ...
            if (outRec1 !== outRec2) {
                return false
            }
            op1b = j.outPt1.next
            while (op1b !== op1 && op1b.pt == j.offPt) {
                op1b = op1b.next
            }
            val reverse1 = op1b.pt.y > j.offPt.y
            op2b = j.outPt2.next
            while (op2b !== op2 && op2b.pt == j.offPt) {
                op2b = op2b.next
            }
            val reverse2 = op2b.pt.y > j.offPt.y
            if (reverse1 == reverse2) {
                return false
            }
            if (reverse1) {
                op1b = op1.duplicate(false)
                op2b = op2.duplicate(true)
                op1.prev = op2
                op2.next = op1
                op1b.next = op2b
                op2b.prev = op1b
                j.outPt1 = op1
                j.outPt2 = op1b
                return true
            } else {
                op1b = op1.duplicate(true)
                op2b = op2.duplicate(false)
                op1.next = op2
                op2.prev = op1
                op1b.prev = op2b
                op2b.next = op1b
                j.outPt1 = op1
                j.outPt2 = op1b
                return true
            }
        } else if (isHorizontal) {
            //treat horizontal joins differently to non-horizontal joins since with
            //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt
            //may be anywhere along the horizontal edge.
            op1b = op1
            while (op1.prev.pt.y == op1.pt.y && op1.prev !== op1b && op1.prev !== op2) {
                op1 = op1.prev
            }
            while (op1b.next.pt.y == op1b.pt.y && op1b.next !== op1 && op1b.next !== op2) {
                op1b = op1b.next
            }
            if (op1b.next === op1 || op1b.next === op2) {
                return false
            } //a flat 'polygon'

            op2b = op2
            while (op2.prev.pt.y == op2.pt.y && op2.prev !== op2b && op2.prev !== op1b) {
                op2 = op2.prev
            }
            while (op2b.next.pt.y == op2b.pt.y && op2b.next !== op2 && op2b.next !== op1) {
                op2b = op2b.next
            }
            if (op2b.next === op2 || op2b.next === op1) {
                return false
            } //a flat 'polygon'

            val LeftV = LongArray(1)
            val RightV = LongArray(1)
            //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges
            if (!getOverlap(op1.pt.x, op1b.pt.x, op2.pt.x, op2b.pt.x, LeftV, RightV)) {
                return false
            }
            val Left = LeftV[0]
            val Right = RightV[0]

            //DiscardLeftSide: when overlapping edges are joined, a spike will created
            //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up
            //on the discard Side as either may still be needed for other joins ...
            val Pt: LongPoint
            val DiscardLeftSide: Boolean
            if (op1.pt.x >= Left && op1.pt.x <= Right) {
                Pt = LongPoint(op1.pt)
                DiscardLeftSide = op1.pt.x > op1b.pt.x
            } else if (op2.pt.x >= Left && op2.pt.x <= Right) {
                Pt = LongPoint(op2.pt)
                DiscardLeftSide = op2.pt.x > op2b.pt.x
            } else if (op1b.pt.x >= Left && op1b.pt.x <= Right) {
                Pt = LongPoint(op1b.pt)
                DiscardLeftSide = op1b.pt.x > op1.pt.x
            } else {
                Pt = LongPoint(op2b.pt)
                DiscardLeftSide = op2b.pt.x > op2.pt.x
            }
            j.outPt1 = op1
            j.outPt2 = op2
            return joinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide)
        } else {
            //nb: For non-horizontal joins ...
            //    1. Jr.OutPt1.getPt().getY() == Jr.OutPt2.getPt().getY()
            //    2. Jr.OutPt1.Pt > Jr.OffPt.getY()

            //make sure the polygons are correctly oriented ...
            op1b = op1.next
            while (op1b.pt == op1.pt && op1b !== op1) {
                op1b = op1b.next
            }
            val Reverse1 = op1b.pt.y > op1.pt.y || !Point.slopesEqual(op1.pt, op1b.pt, j.offPt, useFullRange)
            if (Reverse1) {
                op1b = op1.prev
                while (op1b.pt == op1.pt && op1b !== op1) {
                    op1b = op1b.prev
                }
                if (op1b.pt.y > op1.pt.y || !Point.slopesEqual(op1.pt, op1b.pt, j.offPt, useFullRange)) {
                    return false
                }
            }
            op2b = op2.next
            while (op2b.pt == op2.pt && op2b !== op2) {
                op2b = op2b.next
            }
            val Reverse2 = op2b.pt.y > op2.pt.y || !Point.slopesEqual(op2.pt, op2b.pt, j.offPt, useFullRange)
            if (Reverse2) {
                op2b = op2.prev
                while (op2b.pt == op2.pt && op2b !== op2) {
                    op2b = op2b.prev
                }
                if (op2b.pt.y > op2.pt.y || !Point.slopesEqual(op2.pt, op2b.pt, j.offPt, useFullRange)) {
                    return false
                }
            }

            if (op1b === op1 || op2b === op2 || op1b === op2b || outRec1 === outRec2 && Reverse1 == Reverse2) {
                return false
            }

            if (Reverse1) {
                op1b = op1.duplicate(false)
                op2b = op2.duplicate(true)
                op1.prev = op2
                op2.next = op1
                op1b.next = op2b
                op2b.prev = op1b
                j.outPt1 = op1
                j.outPt2 = op1b
                return true
            } else {
                op1b = op1.duplicate(true)
                op2b = op2.duplicate(false)
                op1.next = op2
                op2.prev = op1
                op1b.prev = op2b
                op2b.next = op1b
                j.outPt1 = op1
                j.outPt2 = op1b
                return true
            }
        }
    }

    protected val polyOuts: MutableList<OutRec>

    private var clipType: Clipper.ClipType? = null

    private var scanbeam: ClipperBase.Scanbeam? = null

    private var maxima: Path.Maxima? = null

    private var activeEdges: Edge? = null

    private var sortedEdges: Edge? = null

    private val intersectList: MutableList<IntersectNode>

    private val intersectNodeComparer: Comparator<IntersectNode>

    private var clipFillType: Clipper.PolyFillType? = null

    //------------------------------------------------------------------------------

    private var subjFillType: Clipper.PolyFillType? = null

    //------------------------------------------------------------------------------

    private val joins: MutableList<Join>

    //------------------------------------------------------------------------------

    private val ghostJoins: MutableList<Join>

    private var usingPolyTree: Boolean = false

    var zFillFunction: Clipper.ZFillCallback? = null

    //------------------------------------------------------------------------------

    private val reverseSolution: Boolean

    //------------------------------------------------------------------------------

    private val strictlySimple: Boolean

    init {
        scanbeam = null
        maxima = null
        activeEdges = null
        sortedEdges = null
        intersectList = ArrayList<IntersectNode>()
        intersectNodeComparer = Comparator<com.itextpdf.text.pdf.parser.clipper.DefaultClipper.IntersectNode> { o1, o2 ->
            val i = o2.pt.y - o1.pt.y
            if (i > 0) {
                1
            } else if (i < 0) {
                -1
            } else {
                0
            }
        }

        usingPolyTree = false
        polyOuts = ArrayList<OutRec>()
        joins = ArrayList<Join>()
        ghostJoins = ArrayList<Join>()
        reverseSolution = Clipper.REVERSE_SOLUTION and InitOptions != 0
        strictlySimple = Clipper.STRICTLY_SIMPLE and InitOptions != 0

        zFillFunction = null

    }


    private fun insertScanbeam(Y: Long) {
        //single-linked list: sorted descending, ignoring dups.
        if (scanbeam == null) {
            scanbeam = ClipperBase.Scanbeam()
            scanbeam!!.next = null
            scanbeam!!.y = Y
        } else if (Y > scanbeam!!.y) {
            val newSb = ClipperBase.Scanbeam()
            newSb.y = Y
            newSb.next = scanbeam
            scanbeam = newSb
        } else {
            var sb2: ClipperBase.Scanbeam = scanbeam
            while (sb2.next != null && Y <= sb2.next.y) sb2 = sb2.next
            if (Y == sb2.y) return  //ie ignores duplicates
            val newSb = ClipperBase.Scanbeam()
            newSb.y = Y
            newSb.next = sb2.next
            sb2.next = newSb
        }
    }
    //------------------------------------------------------------------------------

    private fun InsertMaxima(X: Long) {
        //double-linked list: sorted ascending, ignoring dups.
        val newMax = Path.Maxima()
        newMax.X = X
        if (maxima == null) {
            maxima = newMax
            maxima!!.Next = null
            maxima!!.Prev = null
        } else if (X < maxima!!.X) {
            newMax.Next = maxima
            newMax.Prev = null
            maxima = newMax
        } else {
            var m: Path.Maxima = maxima
            while (m.Next != null && X >= m.Next.X) m = m.Next
            if (X == m.X) return  //ie ignores duplicates (& CG to clean up newMax)
            //insert newMax between m and m.Next ...
            newMax.Next = m.Next
            newMax.Prev = m
            if (m.Next != null) m.Next.Prev = newMax
            m.Next = newMax
        }
    }
    //------------------------------------------------------------------------------

    private fun addEdgeToSEL(edge: Edge) {
        LOGGER.entering(DefaultClipper::class.java.name, "addEdgeToSEL")

        //SEL pointers in PEdge are reused to build a list of horizontal edges.
        //However, we don't need to worry about order with horizontal edge processing.
        if (sortedEdges == null) {
            sortedEdges = edge
            edge.prevInSEL = null
            edge.nextInSEL = null
        } else {
            edge.nextInSEL = sortedEdges
            edge.prevInSEL = null
            sortedEdges!!.prevInSEL = edge
            sortedEdges = edge
        }
    }

    private fun addGhostJoin(Op: Path.OutPt, OffPt: LongPoint) {
        val j = Join()
        j.outPt1 = Op
        j.offPt = OffPt
        ghostJoins.add(j)
    }

    //------------------------------------------------------------------------------

    private fun addJoin(Op1: Path.OutPt, Op2: Path.OutPt, OffPt: LongPoint) {
        LOGGER.entering(DefaultClipper::class.java.name, "addJoin")
        val j = Join()
        j.outPt1 = Op1
        j.outPt2 = Op2
        j.offPt = OffPt
        joins.add(j)
    }

    //------------------------------------------------------------------------------

    private fun addLocalMaxPoly(e1: Edge, e2: Edge, pt: LongPoint) {
        addOutPt(e1, pt)
        if (e2.windDelta == 0) {
            addOutPt(e2, pt)
        }
        if (e1.outIdx == e2.outIdx) {
            e1.outIdx = Edge.UNASSIGNED
            e2.outIdx = Edge.UNASSIGNED
        } else if (e1.outIdx < e2.outIdx) {
            appendPolygon(e1, e2)
        } else {
            appendPolygon(e2, e1)
        }
    }

    //------------------------------------------------------------------------------

    private fun addLocalMinPoly(e1: Edge, e2: Edge, pt: LongPoint): Path.OutPt {
        LOGGER.entering(DefaultClipper::class.java.name, "addLocalMinPoly")
        val result: Path.OutPt
        val e: Edge
        val prevE: Edge?
        if (e2.isHorizontal || e1.deltaX > e2.deltaX) {
            result = addOutPt(e1, pt)
            e2.outIdx = e1.outIdx
            e1.side = Edge.Side.LEFT
            e2.side = Edge.Side.RIGHT
            e = e1
            if (e.prevInAEL === e2) {
                prevE = e2.prevInAEL
            } else {
                prevE = e.prevInAEL
            }
        } else {
            result = addOutPt(e2, pt)
            e1.outIdx = e2.outIdx
            e1.side = Edge.Side.RIGHT
            e2.side = Edge.Side.LEFT
            e = e2
            if (e.prevInAEL === e1) {
                prevE = e1.prevInAEL
            } else {
                prevE = e.prevInAEL
            }
        }

        if (prevE != null && prevE.outIdx >= 0 &&
                Edge.topX(prevE, pt.y) == Edge.topX(e, pt.y) &&
                Edge.slopesEqual(e, prevE, useFullRange) &&
                e.windDelta != 0 && prevE.windDelta != 0) {
            val outPt = addOutPt(prevE, pt)
            addJoin(result, outPt, e.top)
        }
        return result
    }

    private fun addOutPt(e: Edge, pt: LongPoint): Path.OutPt {
        LOGGER.entering(DefaultClipper::class.java.name, "addOutPt")
        if (e.outIdx < 0) {
            val outRec = createOutRec()
            outRec.isOpen = e.windDelta == 0
            val newOp = Path.OutPt()
            outRec.points = newOp
            newOp.idx = outRec.Idx
            newOp.pt = pt
            newOp.next = newOp
            newOp.prev = newOp
            if (!outRec.isOpen)
                setHoleState(e, outRec)
            e.outIdx = outRec.Idx //nb: do this after SetZ !
            return newOp
        } else {
            val outRec = polyOuts[e.outIdx]
            //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'
            val op = outRec.points
            val ToFront = e.side == Edge.Side.LEFT
            LOGGER.finest("op=" + op.pointCount)
            LOGGER.finest(ToFront + " " + pt + " " + op.pt)
            if (ToFront && pt == op.pt) {
                return op
            } else if (!ToFront && pt == op.prev.pt) {
                return op.prev
            }

            val newOp = Path.OutPt()
            newOp.idx = outRec.Idx
            newOp.pt = LongPoint(pt)
            newOp.next = op
            newOp.prev = op.prev
            newOp.prev.next = newOp
            op.prev = newOp
            if (ToFront) {
                outRec.points = newOp
            }
            return newOp
        }
    }

    private fun GetLastOutPt(e: Edge): Path.OutPt {
        val outRec = polyOuts[e.outIdx]
        if (e.side == Edge.Side.LEFT)
            return outRec.points
        else
            return outRec.points!!.prev
    }
    //------------------------------------------------------------------------------

    private fun appendPolygon(e1: Edge, e2: Edge) {
        LOGGER.entering(DefaultClipper::class.java.name, "appendPolygon")

        //get the start and ends of both output polygons ...
        val outRec1 = polyOuts[e1.outIdx]
        val outRec2 = polyOuts[e2.outIdx]
        LOGGER.finest("" + e1.outIdx)
        LOGGER.finest("" + e2.outIdx)

        val holeStateRec: OutRec
        if (isParam1RightOfParam2(outRec1, outRec2)) {
            holeStateRec = outRec2
        } else if (isParam1RightOfParam2(outRec2, outRec1)) {
            holeStateRec = outRec1
        } else {
            holeStateRec = Path.OutPt.getLowerMostRec(outRec1, outRec2)
        }

        val p1_lft = outRec1.points
        val p1_rt = p1_lft.prev
        val p2_lft = outRec2.points
        val p2_rt = p2_lft.prev

        LOGGER.finest("p1_lft.getPointCount() = " + p1_lft.pointCount)
        LOGGER.finest("p1_rt.getPointCount() = " + p1_rt.pointCount)
        LOGGER.finest("p2_lft.getPointCount() = " + p2_lft.pointCount)
        LOGGER.finest("p2_rt.getPointCount() = " + p2_rt.pointCount)

        val side: Edge.Side
        //join e2 poly onto e1 poly and delete pointers to e2 ...
        if (e1.side == Edge.Side.LEFT) {
            if (e2.side == Edge.Side.LEFT) {
                //z y x a b c
                p2_lft.reversePolyPtLinks()
                p2_lft.next = p1_lft
                p1_lft.prev = p2_lft
                p1_rt.next = p2_rt
                p2_rt.prev = p1_rt
                outRec1.points = p2_rt
            } else {
                //x y z a b c
                p2_rt.next = p1_lft
                p1_lft.prev = p2_rt
                p2_lft.prev = p1_rt
                p1_rt.next = p2_lft
                outRec1.points = p2_lft
            }
            side = Edge.Side.LEFT
        } else {
            if (e2.side == Edge.Side.RIGHT) {
                //a b c z y x
                p2_lft.reversePolyPtLinks()
                p1_rt.next = p2_rt
                p2_rt.prev = p1_rt
                p2_lft.next = p1_lft
                p1_lft.prev = p2_lft
            } else {
                //a b c x y z
                p1_rt.next = p2_lft
                p2_lft.prev = p1_rt
                p1_lft.prev = p2_rt
                p2_rt.next = p1_lft
            }
            side = Edge.Side.RIGHT
        }
        outRec1.bottomPt = null
        if (holeStateRec == outRec2) {
            if (outRec2.firstLeft !== outRec1) {
                outRec1.firstLeft = outRec2.firstLeft
            }
            outRec1.isHole = outRec2.isHole
        }
        outRec2.points = null
        outRec2.bottomPt = null

        outRec2.firstLeft = outRec1

        val OKIdx = e1.outIdx
        val ObsoleteIdx = e2.outIdx

        e1.outIdx = Edge.UNASSIGNED //nb: safe because we only get here via AddLocalMaxPoly
        e2.outIdx = Edge.UNASSIGNED

        var e = activeEdges
        while (e != null) {
            if (e.outIdx == ObsoleteIdx) {
                e.outIdx = OKIdx
                e.side = side
                break
            }
            e = e.nextInAEL
        }
        outRec2.Idx = outRec1.Idx
    }

    //------------------------------------------------------------------------------

    private fun buildIntersectList(topY: Long) {
        if (activeEdges == null) {
            return
        }

        //prepare for sorting ...
        var e = activeEdges
        sortedEdges = e
        while (e != null) {
            e.prevInSEL = e.prevInAEL
            e.nextInSEL = e.nextInAEL
            e.current.setX(Edge.topX(e, topY))
            e = e.nextInAEL
        }

        //bubblesort ...
        var isModified = true
        while (isModified && sortedEdges != null) {
            isModified = false
            e = sortedEdges
            while (e!!.nextInSEL != null) {
                val eNext = e.nextInSEL
                val pt = arrayOfNulls<LongPoint>(1)
                if (e.current.x > eNext.current.x) {
                    intersectPoint(e, eNext, pt)
                    val newNode = IntersectNode()
                    newNode.edge1 = e
                    newNode.Edge2 = eNext
                    newNode.pt = pt[0]
                    intersectList.add(newNode)

                    swapPositionsInSEL(e, eNext)
                    isModified = true
                } else {
                    e = eNext
                }
            }
            if (e.prevInSEL != null) {
                e.prevInSEL.nextInSEL = null
            } else {
                break
            }
        }
        sortedEdges = null
    }

    //------------------------------------------------------------------------------

    private fun buildResult(polyg: Paths) {
        polyg.clear()
        for (i in polyOuts.indices) {
            val outRec = polyOuts[i]
            if (outRec.points == null) {
                continue
            }
            var p: Path.OutPt = outRec.points.prev
            val cnt = p.pointCount
            LOGGER.finest("cnt = " + cnt)
            if (cnt < 2) {
                continue
            }
            val pg = Path(cnt)
            for (j in 0..cnt - 1) {
                pg.add(p.pt)
                p = p.prev
            }
            polyg.add(pg)
        }
    }

    private fun buildResult2(polytree: PolyTree) {
        polytree.Clear()

        //add each output polygon/contour to polytree ...
        for (i in polyOuts.indices) {
            val outRec = polyOuts[i]
            val cnt = if (outRec.points != null) outRec.points.pointCount else 0
            if (outRec.isOpen && cnt < 2 || !outRec.isOpen && cnt < 3) {
                continue
            }
            outRec.fixHoleLinkage()
            val pn = PolyNode()
            polytree.allPolys.add(pn)
            outRec.polyNode = pn
            var op: Path.OutPt = outRec.points.prev
            for (j in 0..cnt - 1) {
                pn.polygon.add(op.pt)
                op = op.prev
            }
        }

        //fixup PolyNode links etc ...
        for (i in polyOuts.indices) {
            val outRec = polyOuts[i]
            if (outRec.polyNode == null) {
                continue
            } else if (outRec.isOpen) {
                outRec.polyNode.isOpen = true
                polytree.addChild(outRec.polyNode)
            } else if (outRec.firstLeft != null && outRec.firstLeft!!.polyNode != null) {
                outRec.firstLeft!!.polyNode.addChild(outRec.polyNode)
            } else {
                polytree.addChild(outRec.polyNode)
            }
        }
    }

    private fun copyAELToSEL() {
        var e = activeEdges
        sortedEdges = e
        while (e != null) {
            e.prevInSEL = e.prevInAEL
            e.nextInSEL = e.nextInAEL
            e = e.nextInAEL
        }
    }

    private fun createOutRec(): OutRec {
        val result = OutRec()
        result.Idx = Edge.UNASSIGNED
        result.isHole = false
        result.isOpen = false
        result.firstLeft = null
        result.points = null
        result.bottomPt = null
        result.polyNode = null
        polyOuts.add(result)
        result.Idx = polyOuts.size - 1
        return result
    }

    private fun deleteFromAEL(e: Edge) {
        LOGGER.entering(DefaultClipper::class.java.name, "deleteFromAEL")

        val AelPrev = e.prevInAEL
        val AelNext = e.nextInAEL
        if (AelPrev == null && AelNext == null && e !== activeEdges) {
            return  //already deleted
        }
        if (AelPrev != null) {
            AelPrev.nextInAEL = AelNext
        } else {
            activeEdges = AelNext
        }
        if (AelNext != null) {
            AelNext.prevInAEL = AelPrev
        }
        e.nextInAEL = null
        e.prevInAEL = null
        LOGGER.exiting(DefaultClipper::class.java.name, "deleteFromAEL")
    }

    private fun deleteFromSEL(e: Edge) {
        LOGGER.entering(DefaultClipper::class.java.name, "deleteFromSEL")

        val SelPrev = e.prevInSEL
        val SelNext = e.nextInSEL
        if (SelPrev == null && SelNext == null && e != sortedEdges) {
            return  //already deleted
        }
        if (SelPrev != null) {
            SelPrev.nextInSEL = SelNext
        } else {
            sortedEdges = SelNext
        }
        if (SelNext != null) {
            SelNext.prevInSEL = SelPrev
        }
        e.nextInSEL = null
        e.prevInSEL = null
    }

    private fun doHorzSegmentsOverlap(seg1a: Long, seg1b: Long, seg2a: Long, seg2b: Long): Boolean {
        var seg1a = seg1a
        var seg1b = seg1b
        var seg2a = seg2a
        var seg2b = seg2b
        if (seg1a > seg1b) {
            val tmp = seg1a
            seg1a = seg1b
            seg1b = tmp
        }
        if (seg2a > seg2b) {
            val tmp = seg2a
            seg2a = seg2b
            seg2b = tmp
        }
        return seg1a < seg2b && seg2a < seg1b
    }

    private fun doMaxima(e: Edge) {
        val eMaxPair = e.maximaPair
        if (eMaxPair == null) {
            if (e.outIdx >= 0) {
                addOutPt(e, e.top)
            }
            deleteFromAEL(e)
            return
        }

        var eNext: Edge? = e.nextInAEL
        while (eNext != null && eNext !== eMaxPair) {
            val tmp = LongPoint(e.top)
            intersectEdges(e, eNext, tmp)
            e.top = tmp
            swapPositionsInAEL(e, eNext)
            eNext = e.nextInAEL
        }

        if (e.outIdx == Edge.UNASSIGNED && eMaxPair.outIdx == Edge.UNASSIGNED) {
            deleteFromAEL(e)
            deleteFromAEL(eMaxPair)
        } else if (e.outIdx >= 0 && eMaxPair.outIdx >= 0) {
            if (e.outIdx >= 0) {
                addLocalMaxPoly(e, eMaxPair, e.top)
            }
            deleteFromAEL(e)
            deleteFromAEL(eMaxPair)
        } else if (e.windDelta == 0) {
            if (e.outIdx >= 0) {
                addOutPt(e, e.top)
                e.outIdx = Edge.UNASSIGNED
            }
            deleteFromAEL(e)

            if (eMaxPair.outIdx >= 0) {
                addOutPt(eMaxPair, e.top)
                eMaxPair.outIdx = Edge.UNASSIGNED
            }
            deleteFromAEL(eMaxPair)
        } else {
            throw IllegalStateException("DoMaxima error")
        }
    }

    //------------------------------------------------------------------------------

    private fun doSimplePolygons() {
        var i = 0
        while (i < polyOuts.size) {
            val outrec = polyOuts[i++]
            var op: Path.OutPt? = outrec.points
            if (op == null || outrec.isOpen) {
                continue
            }
            do
            //for each Pt in Polygon until duplicate found do ...
            {
                var op2: Path.OutPt = op!!.next
                while (op2 !== outrec.points) {
                    if (op.pt == op2.pt && op2.next != op && op2.prev != op) {
                        //split the polygon into two ...
                        val op3 = op.prev
                        val op4 = op2.prev
                        op.prev = op4
                        op4.next = op
                        op2.prev = op3
                        op3.next = op2

                        outrec.points = op
                        val outrec2 = createOutRec()
                        outrec2.points = op2
                        updateOutPtIdxs(outrec2)
                        if (poly2ContainsPoly1(outrec2.points, outrec.points)) {
                            //OutRec2 is contained by OutRec1 ...
                            outrec2.isHole = !outrec.isHole
                            outrec2.firstLeft = outrec
                            if (usingPolyTree) {
                                fixupFirstLefts2(outrec2, outrec)
                            }
                        } else if (poly2ContainsPoly1(outrec.points, outrec2.points)) {
                            //OutRec1 is contained by OutRec2 ...
                            outrec2.isHole = outrec.isHole
                            outrec.isHole = !outrec2.isHole
                            outrec2.firstLeft = outrec.firstLeft
                            outrec.firstLeft = outrec2
                            if (usingPolyTree) {
                                fixupFirstLefts2(outrec, outrec2)
                            }
                        } else {
                            //the 2 polygons are separate ...
                            outrec2.isHole = outrec.isHole
                            outrec2.firstLeft = outrec.firstLeft
                            if (usingPolyTree) {
                                fixupFirstLefts1(outrec, outrec2)
                            }
                        }
                        op2 = op //ie get ready for the next iteration
                    }
                    op2 = op2.next
                }
                op = op.next
            } while (op !== outrec.points)
        }
    }

    //------------------------------------------------------------------------------

    private fun EdgesAdjacent(inode: IntersectNode): Boolean {
        return inode.edge1.nextInSEL === inode.Edge2 || inode.edge1.prevInSEL === inode.Edge2
    }

    //------------------------------------------------------------------------------


    fun execute(clipType: Clipper.ClipType, solution: Paths,
                FillType: Clipper.PolyFillType): Boolean {
        return execute(clipType, solution, FillType, FillType)
    }

    override fun execute(clipType: Clipper.ClipType, polytree: PolyTree): Boolean {
        return execute(clipType, polytree, Clipper.PolyFillType.EVEN_ODD)
    }

    fun execute(clipType: Clipper.ClipType, polytree: PolyTree,
                FillType: Clipper.PolyFillType): Boolean {
        return execute(clipType, polytree, FillType, FillType)
    }


    override fun execute(clipType: Clipper.ClipType, solution: Paths): Boolean {
        return execute(clipType, solution, Clipper.PolyFillType.EVEN_ODD)
    }

    override fun execute(clipType: Clipper.ClipType, solution: Paths, subjFillType: Clipper.PolyFillType, clipFillType: Clipper.PolyFillType): Boolean {

        synchronized (this) {

            if (hasOpenPaths) {
                throw IllegalStateException("Error: PolyTree struct is needed for open path clipping.")
            }

            solution.clear()
            this.subjFillType = subjFillType
            this.clipFillType = clipFillType
            this.clipType = clipType
            usingPolyTree = false
            val succeeded: Boolean
            try {
                succeeded = executeInternal()
                //build the return polygons ...
                if (succeeded) {
                    buildResult(solution)
                }
                return succeeded
            } finally {
                polyOuts.clear()

            }
        }

    }

    override fun execute(clipType: Clipper.ClipType, polytree: PolyTree, subjFillType: Clipper.PolyFillType, clipFillType: Clipper.PolyFillType): Boolean {
        synchronized (this) {
            this.subjFillType = subjFillType
            this.clipFillType = clipFillType
            this.clipType = clipType
            usingPolyTree = true
            val succeeded: Boolean
            try {
                succeeded = executeInternal()
                //build the return polygons ...
                if (succeeded) {
                    buildResult2(polytree)
                }
            } finally {
                polyOuts.clear()
            }
            return succeeded
        }
    }

    //------------------------------------------------------------------------------

    private fun executeInternal(): Boolean {
        try {
            reset()
            if (currentLM == null)
                return false

            var botY = popScanbeam()
            do {
                insertLocalMinimaIntoAEL(botY)
                processHorizontals()
                ghostJoins.clear()
                if (scanbeam == null)
                    break
                val topY = popScanbeam()
                if (!processIntersections(topY))
                    return false
                processEdgesAtTopOfScanbeam(topY)
                botY = topY
            } while (scanbeam != null || currentLM != null)

            //fix orientations ...
            for (i in polyOuts.indices) {
                val outRec = polyOuts[i]
                if (outRec.points == null || outRec.isOpen)
                    continue
                if (outRec.isHole xor reverseSolution == outRec.area() > 0)
                    outRec.points.reversePolyPtLinks()
            }

            joinCommonEdges()

            for (i in polyOuts.indices) {
                val outRec = polyOuts[i]
                if (outRec.points == null)
                    continue
                else if (outRec.isOpen)
                    fixupOutPolyline(outRec)
                else
                    fixupOutPolygon(outRec)
            }

            if (strictlySimple)
                doSimplePolygons()
            return true
        } finally {
            joins.clear()
            ghostJoins.clear()
        }//catch { return false; }
    }

    //------------------------------------------------------------------------------

    private fun fixupFirstLefts1(OldOutRec: OutRec, NewOutRec: OutRec) {
        for (i in polyOuts.indices) {
            val outRec = polyOuts[i]
            if (outRec.points == null || outRec.firstLeft == null) {
                continue
            }
            val firstLeft = ClipperBase.parseFirstLeft(outRec.firstLeft)
            if (firstLeft == OldOutRec) {
                if (poly2ContainsPoly1(outRec.points, NewOutRec.points)) {
                    outRec.firstLeft = NewOutRec
                }
            }
        }
    }

    private fun fixupFirstLefts2(OldOutRec: OutRec, NewOutRec: OutRec) {
        for (outRec in polyOuts) {
            if (outRec.firstLeft === OldOutRec) {
                outRec.firstLeft = NewOutRec
            }
        }
    }

    private fun fixupIntersectionOrder(): Boolean {
        //pre-condition: intersections are sorted bottom-most first.
        //Now it's crucial that intersections are made only between adjacent edges,
        //so to ensure this the order of intersections may need adjusting ...
        Collections.sort(intersectList, intersectNodeComparer)

        copyAELToSEL()
        val cnt = intersectList.size
        for (i in 0..cnt - 1) {
            if (!EdgesAdjacent(intersectList[i])) {
                var j = i + 1
                while (j < cnt && !EdgesAdjacent(intersectList[j])) {
                    j++
                }
                if (j == cnt) {
                    return false
                }

                val tmp = intersectList[i]
                intersectList[i] = intersectList[j]
                intersectList[j] = tmp

            }
            swapPositionsInSEL(intersectList[i].edge1, intersectList[i].Edge2)
        }
        return true
    }

    //----------------------------------------------------------------------

    private fun fixupOutPolyline(outrec: OutRec) {
        var pp: Path.OutPt = outrec.points
        var lastPP: Path.OutPt = pp.prev
        while (pp !== lastPP) {
            pp = pp.next
            if (pp.pt == pp.prev.pt) {
                if (pp === lastPP) lastPP = pp.prev
                val tmpPP = pp.prev
                tmpPP.next = pp.next
                pp.next.prev = tmpPP
                pp = tmpPP
            }
        }
        if (pp === pp.prev) outrec.points = null
    }

    private fun fixupOutPolygon(outRec: OutRec) {
        //FixupOutPolygon() - removes duplicate points and simplifies consecutive
        //parallel edges by removing the middle vertex.
        var lastOK: Path.OutPt? = null
        outRec.bottomPt = null
        var pp = outRec.points
        val preserveCol = isPreserveCollinear || strictlySimple
        while (true) {
            if (pp.prev === pp || pp.prev === pp.next) {
                outRec.points = null
                return
            }
            //test for duplicate points and collinear edges ...
            if (pp.pt == pp.next.pt || pp.pt == pp.prev.pt
                    || Point.slopesEqual(pp.prev.pt, pp.pt, pp.next.pt, useFullRange) && (!preserveCol || !Point.isPt2BetweenPt1AndPt3(pp.prev.pt, pp.pt, pp.next.pt))) {
                lastOK = null
                pp.prev.next = pp.next
                pp.next.prev = pp.prev
                pp = pp.prev
            } else if (pp === lastOK) {
                break
            } else {
                if (lastOK == null) {
                    lastOK = pp
                }
                pp = pp.next
            }
        }
        outRec.points = pp
    }

    private fun getOutRec(idx: Int): OutRec {
        var outrec = polyOuts[idx]
        while (outrec !== polyOuts[outrec.Idx]) {
            outrec = polyOuts[outrec.Idx]
        }
        return outrec
    }

    private fun insertEdgeIntoAEL(edge: Edge, startEdge: Edge?) {
        var startEdge = startEdge
        LOGGER.entering(DefaultClipper::class.java.name, "insertEdgeIntoAEL")

        if (activeEdges == null) {
            edge.prevInAEL = null
            edge.nextInAEL = null
            LOGGER.finest("Edge " + edge.outIdx + " -> " + null)
            activeEdges = edge
        } else if (startEdge == null && Edge.doesE2InsertBeforeE1(activeEdges, edge)) {
            edge.prevInAEL = null
            edge.nextInAEL = activeEdges
            LOGGER.finest("Edge " + edge.outIdx + " -> " + edge.nextInAEL.outIdx)
            activeEdges!!.prevInAEL = edge
            activeEdges = edge
        } else {
            LOGGER.finest("activeEdges unchanged")
            if (startEdge == null) {
                startEdge = activeEdges
            }
            while (startEdge!!.nextInAEL != null && !Edge.doesE2InsertBeforeE1(startEdge.nextInAEL, edge)) {
                startEdge = startEdge.nextInAEL
            }
            edge.nextInAEL = startEdge.nextInAEL
            if (startEdge.nextInAEL != null) {
                startEdge.nextInAEL.prevInAEL = edge
            }
            edge.prevInAEL = startEdge
            startEdge.nextInAEL = edge
        }
    }

    //------------------------------------------------------------------------------

    private fun insertLocalMinimaIntoAEL(botY: Long) {
        LOGGER.entering(DefaultClipper::class.java.name, "insertLocalMinimaIntoAEL")

        while (currentLM != null && currentLM!!.y == botY) {
            val lb = currentLM!!.leftBound
            val rb = currentLM!!.rightBound
            popLocalMinima()

            var Op1: Path.OutPt? = null
            if (lb == null) {
                insertEdgeIntoAEL(rb, null)
                updateWindingCount(rb)
                if (rb!!.isContributing(clipFillType, subjFillType, clipType)) {
                    Op1 = addOutPt(rb, rb.bot)
                }
            } else if (rb == null) {
                insertEdgeIntoAEL(lb, null)
                updateWindingCount(lb)
                if (lb.isContributing(clipFillType, subjFillType, clipType)) {
                    Op1 = addOutPt(lb, lb.bot)
                }
                insertScanbeam(lb.top.y)
            } else {
                insertEdgeIntoAEL(lb, null)
                insertEdgeIntoAEL(rb, lb)
                updateWindingCount(lb)
                rb.windCnt = lb.windCnt
                rb.windCnt2 = lb.windCnt2
                if (lb.isContributing(clipFillType, subjFillType, clipType)) {
                    Op1 = addLocalMinPoly(lb, rb, lb.bot)
                }
                insertScanbeam(lb.top.y)
            }

            if (rb != null) {
                if (rb.isHorizontal) {
                    addEdgeToSEL(rb)
                } else {
                    insertScanbeam(rb.top.y)
                }
            }

            if (lb == null || rb == null) {
                continue
            }

            //if output polygons share an Edge with a horizontal rb, they'll need joining later ...
            if (Op1 != null && rb.isHorizontal &&
                    ghostJoins.size > 0 && rb.windDelta != 0) {
                for (i in ghostJoins.indices) {
                    //if the horizontal Rb and a 'ghost' horizontal overlap, then convert
                    //the 'ghost' join to a real join ready for later ...
                    val j = ghostJoins[i]
                    if (doHorzSegmentsOverlap(j.outPt1.pt.x, j.offPt.x, rb.bot.x, rb.top.x)) {
                        addJoin(j.outPt1, Op1, j.offPt)
                    }
                }
            }

            if (lb.outIdx >= 0 && lb.prevInAEL != null &&
                    lb.prevInAEL.current.x == lb.bot.x &&
                    lb.prevInAEL.outIdx >= 0 &&
                    Edge.slopesEqual(lb.prevInAEL, lb, useFullRange) &&
                    lb.windDelta != 0 && lb.prevInAEL.windDelta != 0) {
                val Op2 = addOutPt(lb.prevInAEL, lb.bot)
                addJoin(Op1, Op2, lb.top)
            }

            if (lb.nextInAEL !== rb) {

                if (rb.outIdx >= 0 && rb.prevInAEL.outIdx >= 0 &&
                        Edge.slopesEqual(rb.prevInAEL, rb, useFullRange) &&
                        rb.windDelta != 0 && rb.prevInAEL.windDelta != 0) {
                    val Op2 = addOutPt(rb.prevInAEL, rb.bot)
                    addJoin(Op1, Op2, rb.top)
                }

                var e: Edge? = lb.nextInAEL
                if (e != null) {
                    while (e !== rb) {
                        //nb: For calculating winding counts etc, IntersectEdges() assumes
                        //that param1 will be to the right of param2 ABOVE the intersection ...
                        intersectEdges(rb, e, lb.current) //order important here
                        e = e!!.nextInAEL

                    }
                }
            }
        }
    }

    //------------------------------------------------------------------------------

    //    private void insertScanbeam( long y ) {
    //        LOGGER.entering( DefaultClipper.class.getName(), "insertScanbeam" );
    //
    //        if (scanbeam == null) {
    //            scanbeam = new Scanbeam();
    //            scanbeam.next = null;
    //            scanbeam.y = y;
    //        }
    //        else if (y > scanbeam.y) {
    //            final Scanbeam newSb = new Scanbeam();
    //            newSb.y = y;
    //            newSb.next = scanbeam;
    //            scanbeam = newSb;
    //        }
    //        else {
    //            Scanbeam sb2 = scanbeam;
    //            while (sb2.next != null && y <= sb2.next.y) {
    //                sb2 = sb2.next;
    //            }
    //            if (y == sb2.y) {
    //                return; //ie ignores duplicates
    //            }
    //            final Scanbeam newSb = new Scanbeam();
    //            newSb.y = y;
    //            newSb.next = sb2.next;
    //            sb2.next = newSb;
    //        }
    //    }

    //------------------------------------------------------------------------------

    private fun intersectEdges(e1: Edge, e2: Edge, pt: LongPoint) {
        LOGGER.entering(DefaultClipper::class.java.name, "insersectEdges")

        //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before
        //e2 in AEL except when e1 is being inserted at the intersection point ...

        val e1Contributing = e1.outIdx >= 0
        val e2Contributing = e2.outIdx >= 0

        setZ(pt, e1, e2)

        //if either edge is on an OPEN path ...
        if (e1.windDelta == 0 || e2.windDelta == 0) {
            //ignore subject-subject open path intersections UNLESS they
            //are both open paths, AND they are both 'contributing maximas' ...
            if (e1.windDelta == 0 && e2.windDelta == 0) {
                return
            } else if (e1.polyTyp == e2.polyTyp &&
                    e1.windDelta != e2.windDelta && clipType == Clipper.ClipType.UNION) {
                if (e1.windDelta == 0) {
                    if (e2Contributing) {
                        addOutPt(e1, pt)
                        if (e1Contributing) {
                            e1.outIdx = Edge.UNASSIGNED
                        }
                    }
                } else {
                    if (e1Contributing) {
                        addOutPt(e2, pt)
                        if (e2Contributing) {
                            e2.outIdx = Edge.UNASSIGNED
                        }
                    }
                }
            } else if (e1.polyTyp != e2.polyTyp) {
                if (e1.windDelta == 0 && Math.abs(e2.windCnt) == 1 && (clipType != Clipper.ClipType.UNION || e2.windCnt2 == 0)) {
                    addOutPt(e1, pt)
                    if (e1Contributing) {
                        e1.outIdx = Edge.UNASSIGNED
                    }
                } else if (e2.windDelta == 0 && Math.abs(e1.windCnt) == 1 && (clipType != Clipper.ClipType.UNION || e1.windCnt2 == 0)) {
                    addOutPt(e2, pt)
                    if (e2Contributing) {
                        e2.outIdx = Edge.UNASSIGNED
                    }
                }
            }
            return
        }

        //update winding counts...
        //assumes that e1 will be to the Right of e2 ABOVE the intersection
        if (e1.polyTyp == e2.polyTyp) {
            if (e1.isEvenOddFillType(clipFillType, subjFillType)) {
                val oldE1WindCnt = e1.windCnt
                e1.windCnt = e2.windCnt
                e2.windCnt = oldE1WindCnt
            } else {
                if (e1.windCnt + e2.windDelta == 0) {
                    e1.windCnt = -e1.windCnt
                } else {
                    e1.windCnt += e2.windDelta
                }
                if (e2.windCnt - e1.windDelta == 0) {
                    e2.windCnt = -e2.windCnt
                } else {
                    e2.windCnt -= e1.windDelta
                }
            }
        } else {
            if (!e2.isEvenOddFillType(clipFillType, subjFillType)) {
                e1.windCnt2 += e2.windDelta
            } else {
                e1.windCnt2 = if (e1.windCnt2 == 0) 1 else 0
            }
            if (!e1.isEvenOddFillType(clipFillType, subjFillType)) {
                e2.windCnt2 -= e1.windDelta
            } else {
                e2.windCnt2 = if (e2.windCnt2 == 0) 1 else 0
            }
        }

        val e1FillType: Clipper.PolyFillType
        val e2FillType: Clipper.PolyFillType
        val e1FillType2: Clipper.PolyFillType
        val e2FillType2: Clipper.PolyFillType
        if (e1.polyTyp == Clipper.PolyType.SUBJECT) {
            e1FillType = subjFillType
            e1FillType2 = clipFillType
        } else {
            e1FillType = clipFillType
            e1FillType2 = subjFillType
        }
        if (e2.polyTyp == Clipper.PolyType.SUBJECT) {
            e2FillType = subjFillType
            e2FillType2 = clipFillType
        } else {
            e2FillType = clipFillType
            e2FillType2 = subjFillType
        }

        val e1Wc: Int
        val e2Wc: Int
        when (e1FillType) {
            Clipper.PolyFillType.POSITIVE -> e1Wc = e1.windCnt
            Clipper.PolyFillType.NEGATIVE -> e1Wc = -e1.windCnt
            else -> e1Wc = Math.abs(e1.windCnt)
        }
        when (e2FillType) {
            Clipper.PolyFillType.POSITIVE -> e2Wc = e2.windCnt
            Clipper.PolyFillType.NEGATIVE -> e2Wc = -e2.windCnt
            else -> e2Wc = Math.abs(e2.windCnt)
        }

        if (e1Contributing && e2Contributing) {
            if (e1Wc != 0 && e1Wc != 1 || e2Wc != 0 && e2Wc != 1 || e1.polyTyp != e2.polyTyp && clipType != Clipper.ClipType.XOR) {
                addLocalMaxPoly(e1, e2, pt)
            } else {
                addOutPt(e1, pt)
                addOutPt(e2, pt)
                Edge.swapSides(e1, e2)
                Edge.swapPolyIndexes(e1, e2)
            }
        } else if (e1Contributing) {
            if (e2Wc == 0 || e2Wc == 1) {
                addOutPt(e1, pt)
                Edge.swapSides(e1, e2)
                Edge.swapPolyIndexes(e1, e2)
            }

        } else if (e2Contributing) {
            if (e1Wc == 0 || e1Wc == 1) {
                addOutPt(e2, pt)
                Edge.swapSides(e1, e2)
                Edge.swapPolyIndexes(e1, e2)
            }
        } else if ((e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1)) {
            //neither edge is currently contributing ...
            val e1Wc2: Int
            val e2Wc2: Int
            when (e1FillType2) {
                Clipper.PolyFillType.POSITIVE -> e1Wc2 = e1.windCnt2
                Clipper.PolyFillType.NEGATIVE -> e1Wc2 = -e1.windCnt2
                else -> e1Wc2 = Math.abs(e1.windCnt2)
            }
            when (e2FillType2) {
                Clipper.PolyFillType.POSITIVE -> e2Wc2 = e2.windCnt2
                Clipper.PolyFillType.NEGATIVE -> e2Wc2 = -e2.windCnt2
                else -> e2Wc2 = Math.abs(e2.windCnt2)
            }

            if (e1.polyTyp != e2.polyTyp) {
                addLocalMinPoly(e1, e2, pt)
            } else if (e1Wc == 1 && e2Wc == 1) {
                when (clipType) {
                    Clipper.ClipType.INTERSECTION -> if (e1Wc2 > 0 && e2Wc2 > 0) {
                        addLocalMinPoly(e1, e2, pt)
                    }
                    Clipper.ClipType.UNION -> if (e1Wc2 <= 0 && e2Wc2 <= 0) {
                        addLocalMinPoly(e1, e2, pt)
                    }
                    Clipper.ClipType.DIFFERENCE -> if (e1.polyTyp == Clipper.PolyType.CLIP && e1Wc2 > 0 && e2Wc2 > 0 || e1.polyTyp == Clipper.PolyType.SUBJECT && e1Wc2 <= 0 && e2Wc2 <= 0) {
                        addLocalMinPoly(e1, e2, pt)
                    }
                    Clipper.ClipType.XOR -> addLocalMinPoly(e1, e2, pt)
                }
            } else {
                Edge.swapSides(e1, e2)
            }
        }
    }

    private fun intersectPoint(edge1: Edge, edge2: Edge, ipV: Array<LongPoint>) {
        val ip = ipV[0] = LongPoint()

        val b1: Double
        val b2: Double
        //nb: with very large coordinate values, it's possible for SlopesEqual() to
        //return false but for the edge.Dx value be equal due to double precision rounding.
        if (edge1.deltaX == edge2.deltaX) {
            ip.setY(edge1.current.y)
            ip.setX(Edge.topX(edge1, ip.y))
            return
        }

        if (edge1.delta.x == 0) {
            ip.setX(edge1.bot.x)
            if (edge2.isHorizontal) {
                ip.setY(edge2.bot.y)
            } else {
                b2 = edge2.bot.y - edge2.bot.x / edge2.deltaX
                ip.setY(Math.round(ip.x / edge2.deltaX + b2))
            }
        } else if (edge2.delta.x == 0) {
            ip.setX(edge2.bot.x)
            if (edge1.isHorizontal) {
                ip.setY(edge1.bot.y)
            } else {
                b1 = edge1.bot.y - edge1.bot.x / edge1.deltaX
                ip.setY(Math.round(ip.x / edge1.deltaX + b1))
            }
        } else {
            b1 = edge1.bot.x - edge1.bot.y * edge1.deltaX
            b2 = edge2.bot.x - edge2.bot.y * edge2.deltaX
            val q = (b2 - b1) / (edge1.deltaX - edge2.deltaX)
            ip.setY(Math.round(q))
            if (Math.abs(edge1.deltaX) < Math.abs(edge2.deltaX)) {
                ip.setX(Math.round(edge1.deltaX * q + b1))
            } else {
                ip.setX(Math.round(edge2.deltaX * q + b2))
            }
        }

        if (ip.y < edge1.top.y || ip.y < edge2.top.y) {
            if (edge1.top.y > edge2.top.y) {
                ip.setY(edge1.top.y)
            } else {
                ip.setY(edge2.top.y)
            }
            if (Math.abs(edge1.deltaX) < Math.abs(edge2.deltaX)) {
                ip.setX(Edge.topX(edge1, ip.y))
            } else {
                ip.setX(Edge.topX(edge2, ip.y))
            }
        }
        //finally, don't allow 'ip' to be BELOW curr.getY() (ie bottom of scanbeam) ...
        if (ip.y > edge1.current.y) {
            ip.setY(edge1.current.y)
            //better to use the more vertical edge to derive X ...
            if (Math.abs(edge1.deltaX) > Math.abs(edge2.deltaX)) {
                ip.setX(Edge.topX(edge2, ip.y))
            } else {
                ip.setX(Edge.topX(edge1, ip.y))
            }
        }
    }

    private fun joinCommonEdges() {
        for (i in joins.indices) {
            val join = joins[i]

            val outRec1 = getOutRec(join.outPt1.idx)
            var outRec2 = getOutRec(join.outPt2.idx)

            if (outRec1.points == null || outRec2.points == null) {
                continue
            }
            if (outRec1.isOpen || outRec2.isOpen) continue

            //get the polygon fragment with the correct hole state (FirstLeft)
            //before calling JoinPoints() ...
            val holeStateRec: OutRec
            if (outRec1 === outRec2) {
                holeStateRec = outRec1
            } else if (isParam1RightOfParam2(outRec1, outRec2)) {
                holeStateRec = outRec2
            } else if (isParam1RightOfParam2(outRec2, outRec1)) {
                holeStateRec = outRec1
            } else {
                holeStateRec = Path.OutPt.getLowerMostRec(outRec1, outRec2)
            }

            if (!joinPoints(join, outRec1, outRec2)) {
                continue
            }

            if (outRec1 === outRec2) {
                //instead of joining two polygons, we've just created a new one by
                //splitting one polygon into two.
                outRec1.points = join.outPt1
                outRec1.bottomPt = null
                outRec2 = createOutRec()
                outRec2.points = join.outPt2

                //update all OutRec2.Pts Idx's ...
                updateOutPtIdxs(outRec2)

                //We now need to check every OutRec.FirstLeft pointer. If it points
                //to OutRec1 it may need to point to OutRec2 instead ...
                if (usingPolyTree) {
                    for (j in 0..polyOuts.size - 1 - 1) {
                        val oRec = polyOuts[j]
                        if (oRec.points == null || ClipperBase.parseFirstLeft(oRec.firstLeft) !== outRec1 || oRec.isHole == outRec1.isHole) {
                            continue
                        }
                        if (poly2ContainsPoly1(oRec.points, join.outPt2)) {
                            oRec.firstLeft = outRec2
                        }
                    }
                }

                if (poly2ContainsPoly1(outRec2.points, outRec1.points)) {
                    //outRec2 is contained by outRec1 ...
                    outRec2.isHole = !outRec1.isHole
                    outRec2.firstLeft = outRec1

                    //fixup FirstLeft pointers that may need reassigning to OutRec1
                    if (usingPolyTree) {
                        fixupFirstLefts2(outRec2, outRec1)
                    }

                    if (outRec2.isHole xor reverseSolution == outRec2.area() > 0) {
                        outRec2.points.reversePolyPtLinks()
                    }

                } else if (poly2ContainsPoly1(outRec1.points, outRec2.points)) {
                    //outRec1 is contained by outRec2 ...
                    outRec2.isHole = outRec1.isHole
                    outRec1.isHole = !outRec2.isHole
                    outRec2.firstLeft = outRec1.firstLeft
                    outRec1.firstLeft = outRec2

                    //fixup FirstLeft pointers that may need reassigning to OutRec1
                    if (usingPolyTree) {
                        fixupFirstLefts2(outRec1, outRec2)
                    }

                    if (outRec1.isHole xor reverseSolution == outRec1.area() > 0) {
                        outRec1.points.reversePolyPtLinks()
                    }
                } else {
                    //the 2 polygons are completely separate ...
                    outRec2.isHole = outRec1.isHole
                    outRec2.firstLeft = outRec1.firstLeft

                    //fixup FirstLeft pointers that may need reassigning to OutRec2
                    if (usingPolyTree) {
                        fixupFirstLefts1(outRec1, outRec2)
                    }
                }

            } else {
                //joined 2 polygons together ...

                outRec2.points = null
                outRec2.bottomPt = null
                outRec2.Idx = outRec1.Idx

                outRec1.isHole = holeStateRec.isHole
                if (holeStateRec === outRec2) {
                    outRec1.firstLeft = outRec2.firstLeft
                }
                outRec2.firstLeft = outRec1

                //fixup FirstLeft pointers that may need reassigning to OutRec1
                if (usingPolyTree) {
                    fixupFirstLefts2(outRec2, outRec1)
                }
            }
        }
    }

    private fun popScanbeam(): Long {
        LOGGER.entering(DefaultClipper::class.java.name, "popBeam")

        val y = scanbeam!!.y
        scanbeam = scanbeam!!.next
        return y
    }

    private fun processEdgesAtTopOfScanbeam(topY: Long) {
        LOGGER.entering(DefaultClipper::class.java.name, "processEdgesAtTopOfScanbeam")

        var e = activeEdges
        while (e != null) {
            //1. process maxima, treating them as if they're 'bent' horizontal edges,
            //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.
            var IsMaximaEdge = e.isMaxima(topY.toDouble())

            if (IsMaximaEdge) {
                val eMaxPair = e.maximaPair
                IsMaximaEdge = eMaxPair == null || !eMaxPair.isHorizontal
            }

            if (IsMaximaEdge) {
                if (strictlySimple) InsertMaxima(e.top.x)
                val ePrev = e.prevInAEL
                doMaxima(e)
                if (ePrev == null) {
                    e = activeEdges
                } else {
                    e = ePrev.nextInAEL
                }
            } else {
                //2. promote horizontal edges, otherwise update Curr.getX() and Curr.getY() ...
                if (e.isIntermediate(topY.toDouble()) && e.nextInLML!!.isHorizontal) {
                    val t = arrayOf<Edge>(e)
                    updateEdgeIntoAEL(t)
                    e = t[0]
                    if (e.outIdx >= 0) {
                        addOutPt(e, e.bot)
                    }
                    addEdgeToSEL(e)
                } else {
                    e.current.setX(Edge.topX(e, topY))
                    e.current.setY(topY)
                }

                //When StrictlySimple and 'e' is being touched by another edge, then
                //make sure both edges have a vertex here ...
                if (strictlySimple) {
                    val ePrev = e.prevInAEL
                    if (e.outIdx >= 0 && e.windDelta != 0 && ePrev != null && ePrev.outIdx >= 0 && ePrev.current.x == e.current.x
                            && ePrev.windDelta != 0) {
                        val ip = LongPoint(e.current)

                        setZ(ip, ePrev, e)

                        val op = addOutPt(ePrev, ip)
                        val op2 = addOutPt(e, ip)
                        addJoin(op, op2, ip) //StrictlySimple (type-3) join
                    }
                }

                e = e.nextInAEL
            }
        }

        //3. Process horizontals at the Top of the scanbeam ...
        processHorizontals()
        maxima = null

        //4. Promote intermediate vertices ...
        e = activeEdges
        while (e != null) {
            if (e.isIntermediate(topY.toDouble())) {
                var op: Path.OutPt? = null
                if (e.outIdx >= 0) {
                    op = addOutPt(e, e.top)
                }
                val t = arrayOf<Edge>(e)
                updateEdgeIntoAEL(t)
                e = t[0]

                //if output polygons share an edge, they'll need joining later ...
                val ePrev = e.prevInAEL
                val eNext = e.nextInAEL
                if (ePrev != null && ePrev.current.x == e.bot.x && ePrev.current.y == e.bot.y && op != null
                        && ePrev.outIdx >= 0 && ePrev.current.y > ePrev.top.y && Edge.slopesEqual(e, ePrev, useFullRange) && e.windDelta != 0
                        && ePrev.windDelta != 0) {
                    val op2 = addOutPt(ePrev, e.bot)
                    addJoin(op, op2, e.top)
                } else if (eNext != null && eNext.current.x == e.bot.x && eNext.current.y == e.bot.y && op != null
                        && eNext.outIdx >= 0 && eNext.current.y > eNext.top.y && Edge.slopesEqual(e, eNext, useFullRange) && e.windDelta != 0
                        && eNext.windDelta != 0) {
                    val op2 = addOutPt(eNext, e.bot)
                    addJoin(op, op2, e.top)
                }
            }
            e = e.nextInAEL
        }
        LOGGER.exiting(DefaultClipper::class.java.name, "processEdgesAtTopOfScanbeam")
    }

    private fun processHorizontal(horzEdge: Edge) {
        var horzEdge = horzEdge
        LOGGER.entering(DefaultClipper::class.java.name, "isHorizontal")
        val dir = arrayOfNulls<Clipper.Direction>(1)
        val horzLeft = LongArray(1)
        val horzRight = LongArray(1)
        val IsOpen = horzEdge.outIdx >= 0 && polyOuts[horzEdge.outIdx].isOpen

        getHorzDirection(horzEdge, dir, horzLeft, horzRight)

        var eLastHorz = horzEdge
        var eMaxPair: Edge? = null
        while (eLastHorz.nextInLML != null && eLastHorz.nextInLML!!.isHorizontal) {
            eLastHorz = eLastHorz.nextInLML
        }
        if (eLastHorz.nextInLML == null) {
            eMaxPair = eLastHorz.maximaPair
        }

        var currMax = maxima
        if (currMax != null) {
            //get the first maxima in range (X) ...
            if (dir[0] == Clipper.Direction.LEFT_TO_RIGHT) {
                while (currMax != null && currMax.X <= horzEdge.bot.x)
                    currMax = currMax.Next
                if (currMax != null && currMax.X >= eLastHorz.bot.x)
                    currMax = null
            } else {
                while (currMax!!.Next != null && currMax.Next.X < horzEdge.bot.x)
                    currMax = currMax.Next
                if (currMax.X <= eLastHorz.top.x) currMax = null
            }
        }

        var op1: Path.OutPt? = null
        while (true) {
            //loop through consec. horizontal edges
            val IsLastHorz = horzEdge === eLastHorz
            var e: Edge? = horzEdge.getNextInAEL(dir[0])
            while (e != null) {

                //this code block inserts extra coords into horizontal edges (in output
                //polygons) whereever maxima touch these horizontal edges. This helps
                //'simplifying' polygons (ie if the Simplify property is set).
                if (currMax != null) {
                    if (dir[0] == Clipper.Direction.LEFT_TO_RIGHT) {
                        while (currMax != null && currMax.X < e.current.x) {
                            if (horzEdge.outIdx >= 0 && !IsOpen)
                                addOutPt(horzEdge, LongPoint(currMax.X, horzEdge.bot.y))
                            currMax = currMax.Next
                        }
                    } else {
                        while (currMax != null && currMax.X > e.current.x) {
                            if (horzEdge.outIdx >= 0 && !IsOpen)
                                addOutPt(horzEdge, LongPoint(currMax.X, horzEdge.bot.y))
                            currMax = currMax.Prev
                        }
                    }
                }


                if (dir[0] == Clipper.Direction.LEFT_TO_RIGHT && e.current.x > horzRight[0] || dir[0] == Clipper.Direction.RIGHT_TO_LEFT && e.current.x < horzLeft[0])
                    break
                //Also break if we've got to the end of an intermediate horizontal edge ...
                //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.
                if (e.current.x == horzEdge.top.x && horzEdge.nextInLML != null &&
                        e.deltaX < horzEdge.nextInLML!!.deltaX)
                    break

                if (horzEdge.outIdx >= 0 && !IsOpen)
                //note: may be done multiple times
                {
                    op1 = addOutPt(horzEdge, e.current)
                    var eNextHorz = sortedEdges
                    while (eNextHorz != null) {
                        if (eNextHorz.outIdx >= 0 && doHorzSegmentsOverlap(horzEdge.bot.x,
                                horzEdge.top.x, eNextHorz.bot.x, eNextHorz.top.x)) {
                            val op2 = GetLastOutPt(eNextHorz)
                            addJoin(op2, op1, eNextHorz.top)
                        }
                        eNextHorz = eNextHorz.nextInSEL
                    }
                    addGhostJoin(op1, horzEdge.bot)
                }

                //OK, so far we're still in range of the horizontal Edge  but make sure
                //we're at the last of consec. horizontals when matching with eMaxPair
                if (e === eMaxPair && IsLastHorz) {
                    if (horzEdge.outIdx >= 0)
                        addLocalMaxPoly(horzEdge, eMaxPair, horzEdge.top)
                    deleteFromAEL(horzEdge)
                    deleteFromAEL(eMaxPair)
                    return
                }

                if (dir[0] == Clipper.Direction.LEFT_TO_RIGHT) {
                    val Pt = LongPoint(e.current.x, horzEdge.current.y)
                    intersectEdges(horzEdge, e, Pt)
                } else {
                    val Pt = LongPoint(e.current.x, horzEdge.current.y)
                    intersectEdges(e, horzEdge, Pt)
                }
                val eNext = e.getNextInAEL(dir[0])
                swapPositionsInAEL(horzEdge, e)
                e = eNext

            } //end while

            //Break out of loop if HorzEdge.NextInLML is not also horizontal ...
            if (horzEdge.nextInLML == null || !horzEdge.nextInLML!!.isHorizontal) break

            val temp = arrayOfNulls<Edge>(1)
            temp[0] = horzEdge
            updateEdgeIntoAEL(temp)
            horzEdge = temp[0]

            if (horzEdge.outIdx >= 0) addOutPt(horzEdge, horzEdge.bot)
            getHorzDirection(horzEdge, dir, horzLeft, horzRight)

        } //end for (;;)

        if (horzEdge.outIdx >= 0 && op1 == null) {
            op1 = GetLastOutPt(horzEdge)
            var eNextHorz = sortedEdges
            while (eNextHorz != null) {
                if (eNextHorz.outIdx >= 0 && doHorzSegmentsOverlap(horzEdge.bot.x,
                        horzEdge.top.x, eNextHorz.bot.x, eNextHorz.top.x)) {
                    val op2 = GetLastOutPt(eNextHorz)
                    addJoin(op2, op1, eNextHorz.top)
                }
                eNextHorz = eNextHorz.nextInSEL
            }
            addGhostJoin(op1, horzEdge.top)
        }

        if (horzEdge.nextInLML != null) {
            if (horzEdge.outIdx >= 0) {
                op1 = addOutPt(horzEdge, horzEdge.top)

                val t = arrayOf(horzEdge)
                updateEdgeIntoAEL(t)
                horzEdge = t[0]

                if (horzEdge.windDelta == 0) {
                    return
                }
                //nb: HorzEdge is no longer horizontal here
                val ePrev = horzEdge.prevInAEL
                val eNext = horzEdge.nextInAEL
                if (ePrev != null && ePrev.current.x == horzEdge.bot.x && ePrev.current.y == horzEdge.bot.y
                        && ePrev.windDelta != 0 && ePrev.outIdx >= 0 && ePrev.current.y > ePrev.top.y
                        && Edge.slopesEqual(horzEdge, ePrev, useFullRange)) {
                    val op2 = addOutPt(ePrev, horzEdge.bot)
                    addJoin(op1, op2, horzEdge.top)
                } else if (eNext != null && eNext.current.x == horzEdge.bot.x && eNext.current.y == horzEdge.bot.y
                        && eNext.windDelta != 0 && eNext.outIdx >= 0 && eNext.current.y > eNext.top.y
                        && Edge.slopesEqual(horzEdge, eNext, useFullRange)) {
                    val op2 = addOutPt(eNext, horzEdge.bot)
                    addJoin(op1, op2, horzEdge.top)
                }
            } else {
                val t = arrayOf(horzEdge)
                updateEdgeIntoAEL(t)
                horzEdge = t[0]
            }
        } else {
            if (horzEdge.outIdx >= 0) {
                addOutPt(horzEdge, horzEdge.top)
            }
            deleteFromAEL(horzEdge)
        }
    }

    //------------------------------------------------------------------------------

    private fun processHorizontals() {
        LOGGER.entering(DefaultClipper::class.java.name, "processHorizontals")

        var horzEdge = sortedEdges
        while (horzEdge != null) {
            deleteFromSEL(horzEdge)
            processHorizontal(horzEdge)
            horzEdge = sortedEdges
        }
    }

    //------------------------------------------------------------------------------

    private fun processIntersections(topY: Long): Boolean {
        LOGGER.entering(DefaultClipper::class.java.name, "processIntersections")

        if (activeEdges == null) {
            return true
        }
        try {
            buildIntersectList(topY)
            if (intersectList.size == 0) {
                return true
            }
            if (intersectList.size == 1 || fixupIntersectionOrder()) {
                processIntersectList()
            } else {
                return false
            }
        } catch (e: Exception) {
            sortedEdges = null
            intersectList.clear()
            throw IllegalStateException("ProcessIntersections error", e)
        }

        sortedEdges = null
        return true
    }

    private fun processIntersectList() {
        for (i in intersectList.indices) {
            val iNode = intersectList[i]
            run {
                intersectEdges(iNode.edge1, iNode.Edge2, iNode.pt)
                swapPositionsInAEL(iNode.edge1, iNode.Edge2)
            }
        }
        intersectList.clear()
    }

    //------------------------------------------------------------------------------

    override fun reset() {
        super.reset()
        scanbeam = null
        maxima = null
        activeEdges = null
        sortedEdges = null
        var lm: ClipperBase.LocalMinima? = minimaList
        while (lm != null) {
            insertScanbeam(lm.y)
            lm = lm.next
        }
    }

    private fun setHoleState(e: Edge, outRec: OutRec) {
        var isHole = false
        var e2: Edge? = e.prevInAEL
        while (e2 != null) {
            if (e2.outIdx >= 0 && e2.windDelta != 0) {
                isHole = !isHole
                if (outRec.firstLeft == null) {
                    outRec.firstLeft = polyOuts[e2.outIdx]
                }
            }
            e2 = e2.prevInAEL
        }
        if (isHole) {
            outRec.isHole = true
        }
    }

    private fun setZ(pt: LongPoint, e1: Edge, e2: Edge) {
        if (pt.z != 0 || zFillFunction == null) {
            return
        } else if (pt == e1.bot) {
            pt.setZ(e1.bot.z)
        } else if (pt == e1.top) {
            pt.setZ(e1.top.z)
        } else if (pt == e2.bot) {
            pt.setZ(e2.bot.z)
        } else if (pt == e2.top) {
            pt.setZ(e2.top.z)
        } else {
            zFillFunction!!.zFill(e1.bot, e1.top, e2.bot, e2.top, pt)
        }
    }

    private fun swapPositionsInAEL(edge1: Edge, edge2: Edge) {
        LOGGER.entering(DefaultClipper::class.java.name, "swapPositionsInAEL")

        //check that one or other edge hasn't already been removed from AEL ...
        if (edge1.nextInAEL === edge1.prevInAEL || edge2.nextInAEL === edge2.prevInAEL) {
            return
        }

        if (edge1.nextInAEL === edge2) {
            val next = edge2.nextInAEL
            if (next != null) {
                next.prevInAEL = edge1
            }
            val prev = edge1.prevInAEL
            if (prev != null) {
                prev.nextInAEL = edge2
            }
            edge2.prevInAEL = prev
            edge2.nextInAEL = edge1
            edge1.prevInAEL = edge2
            edge1.nextInAEL = next
        } else if (edge2.nextInAEL === edge1) {
            val next = edge1.nextInAEL
            if (next != null) {
                next.prevInAEL = edge2
            }
            val prev = edge2.prevInAEL
            if (prev != null) {
                prev.nextInAEL = edge1
            }
            edge1.prevInAEL = prev
            edge1.nextInAEL = edge2
            edge2.prevInAEL = edge1
            edge2.nextInAEL = next
        } else {
            val next = edge1.nextInAEL
            val prev = edge1.prevInAEL
            edge1.nextInAEL = edge2.nextInAEL
            if (edge1.nextInAEL != null) {
                edge1.nextInAEL.prevInAEL = edge1
            }
            edge1.prevInAEL = edge2.prevInAEL
            if (edge1.prevInAEL != null) {
                edge1.prevInAEL.nextInAEL = edge1
            }
            edge2.nextInAEL = next
            if (edge2.nextInAEL != null) {
                edge2.nextInAEL.prevInAEL = edge2
            }
            edge2.prevInAEL = prev
            if (edge2.prevInAEL != null) {
                edge2.prevInAEL.nextInAEL = edge2
            }
        }

        if (edge1.prevInAEL == null) {
            activeEdges = edge1
        } else if (edge2.prevInAEL == null) {
            activeEdges = edge2
        }

        LOGGER.exiting(DefaultClipper::class.java.name, "swapPositionsInAEL")
    }

    //------------------------------------------------------------------------------;

    private fun swapPositionsInSEL(edge1: Edge, edge2: Edge) {
        if (edge1.nextInSEL == null && edge1.prevInSEL == null) {
            return
        }
        if (edge2.nextInSEL == null && edge2.prevInSEL == null) {
            return
        }

        if (edge1.nextInSEL === edge2) {
            val next = edge2.nextInSEL
            if (next != null) {
                next.prevInSEL = edge1
            }
            val prev = edge1.prevInSEL
            if (prev != null) {
                prev.nextInSEL = edge2
            }
            edge2.prevInSEL = prev
            edge2.nextInSEL = edge1
            edge1.prevInSEL = edge2
            edge1.nextInSEL = next
        } else if (edge2.nextInSEL === edge1) {
            val next = edge1.nextInSEL
            if (next != null) {
                next.prevInSEL = edge2
            }
            val prev = edge2.prevInSEL
            if (prev != null) {
                prev.nextInSEL = edge1
            }
            edge1.prevInSEL = prev
            edge1.nextInSEL = edge2
            edge2.prevInSEL = edge1
            edge2.nextInSEL = next
        } else {
            val next = edge1.nextInSEL
            val prev = edge1.prevInSEL
            edge1.nextInSEL = edge2.nextInSEL
            if (edge1.nextInSEL != null) {
                edge1.nextInSEL.prevInSEL = edge1
            }
            edge1.prevInSEL = edge2.prevInSEL
            if (edge1.prevInSEL != null) {
                edge1.prevInSEL.nextInSEL = edge1
            }
            edge2.nextInSEL = next
            if (edge2.nextInSEL != null) {
                edge2.nextInSEL.prevInSEL = edge2
            }
            edge2.prevInSEL = prev
            if (edge2.prevInSEL != null) {
                edge2.prevInSEL.nextInSEL = edge2
            }
        }

        if (edge1.prevInSEL == null) {
            sortedEdges = edge1
        } else if (edge2.prevInSEL == null) {
            sortedEdges = edge2
        }
    }

    private fun updateEdgeIntoAEL(eV: Array<Edge>) {
        var e = eV[0]
        if (e.nextInLML == null) {
            throw IllegalStateException("UpdateEdgeIntoAEL: invalid call")
        }
        val AelPrev = e.prevInAEL
        val AelNext = e.nextInAEL
        e.nextInLML!!.outIdx = e.outIdx
        if (AelPrev != null) {
            AelPrev.nextInAEL = e.nextInLML
        } else {
            activeEdges = e.nextInLML
        }
        if (AelNext != null) {
            AelNext.prevInAEL = e.nextInLML
        }
        e.nextInLML!!.side = e.side
        e.nextInLML!!.windDelta = e.windDelta
        e.nextInLML!!.windCnt = e.windCnt
        e.nextInLML!!.windCnt2 = e.windCnt2
        eV[0] = e = e.nextInLML
        e.current = e.bot
        e.prevInAEL = AelPrev
        e.nextInAEL = AelNext
        if (!e.isHorizontal) {
            insertScanbeam(e.top.y)
        }
    }

    private fun updateOutPtIdxs(outrec: OutRec) {
        var op = outrec.points
        do {
            op.idx = outrec.Idx
            op = op.prev
        } while (op !== outrec.points)
    }

    private fun updateWindingCount(edge: Edge) {
        LOGGER.entering(DefaultClipper::class.java.name, "updateWindingCount")

        var e: Edge? = edge.prevInAEL
        //find the edge of the same polytype that immediately preceeds 'edge' in AEL
        while (e != null && (e.polyTyp != edge.polyTyp || e.windDelta == 0)) {
            e = e.prevInAEL
        }
        if (e == null) {
            edge.windCnt = if (edge.windDelta == 0) 1 else edge.windDelta
            edge.windCnt2 = 0
            e = activeEdges //ie get ready to calc WindCnt2
        } else if (edge.windDelta == 0 && clipType != Clipper.ClipType.UNION) {
            edge.windCnt = 1
            edge.windCnt2 = e.windCnt2
            e = e.nextInAEL //ie get ready to calc WindCnt2
        } else if (edge.isEvenOddFillType(clipFillType, subjFillType)) {
            //EvenOdd filling ...
            if (edge.windDelta == 0) {
                //are we inside a subj polygon ...
                var Inside = true
                var e2: Edge? = e.prevInAEL
                while (e2 != null) {
                    if (e2.polyTyp == e.polyTyp && e2.windDelta != 0) {
                        Inside = !Inside
                    }
                    e2 = e2.prevInAEL
                }
                edge.windCnt = if (Inside) 0 else 1
            } else {
                edge.windCnt = edge.windDelta
            }
            edge.windCnt2 = e.windCnt2
            e = e.nextInAEL //ie get ready to calc WindCnt2
        } else {
            //nonZero, Positive or Negative filling ...
            if (e.windCnt * e.windDelta < 0) {
                //prev edge is 'decreasing' WindCount (WC) toward zero
                //so we're outside the previous polygon ...
                if (Math.abs(e.windCnt) > 1) {
                    //outside prev poly but still inside another.
                    //when reversing direction of prev poly use the same WC
                    if (e.windDelta * edge.windDelta < 0) {
                        edge.windCnt = e.windCnt
                    } else {
                        edge.windCnt = e.windCnt + edge.windDelta
                    }
                } else {
                    //now outside all polys of same polytype so set own WC ...
                    edge.windCnt = if (edge.windDelta == 0) 1 else edge.windDelta
                }
            } else {
                //prev edge is 'increasing' WindCount (WC) away from zero
                //so we're inside the previous polygon ...
                if (edge.windDelta == 0) {
                    edge.windCnt = if (e.windCnt < 0) e.windCnt - 1 else e.windCnt + 1
                } else if (e.windDelta * edge.windDelta < 0) {
                    edge.windCnt = e.windCnt
                } else {
                    edge.windCnt = e.windCnt + edge.windDelta
                }
            }
            edge.windCnt2 = e.windCnt2
            e = e.nextInAEL //ie get ready to calc WindCnt2
        }

        //update WindCnt2 ...
        if (edge.isEvenOddAltFillType(clipFillType, subjFillType)) {
            //EvenOdd filling ...
            while (e !== edge) {
                if (e!!.windDelta != 0) {
                    edge.windCnt2 = if (edge.windCnt2 == 0) 1 else 0
                }
                e = e.nextInAEL
            }
        } else {
            //nonZero, Positive or Negative filling ...
            while (e !== edge) {
                edge.windCnt2 += e!!.windDelta
                e = e.nextInAEL
            }
        }
    }

    companion object {

        private fun getHorzDirection(HorzEdge: Edge, Dir: Array<Clipper.Direction>, Left: LongArray, Right: LongArray) {
            if (HorzEdge.bot.x < HorzEdge.top.x) {
                Left[0] = HorzEdge.bot.x
                Right[0] = HorzEdge.top.x
                Dir[0] = Clipper.Direction.LEFT_TO_RIGHT
            } else {
                Left[0] = HorzEdge.top.x
                Right[0] = HorzEdge.bot.x
                Dir[0] = Clipper.Direction.RIGHT_TO_LEFT
            }
        }

        private fun getOverlap(a1: Long, a2: Long, b1: Long, b2: Long, Left: LongArray, Right: LongArray): Boolean {
            if (a1 < a2) {
                if (b1 < b2) {
                    Left[0] = Math.max(a1, b1)
                    Right[0] = Math.min(a2, b2)
                } else {
                    Left[0] = Math.max(a1, b2)
                    Right[0] = Math.min(a2, b1)
                }
            } else {
                if (b1 < b2) {
                    Left[0] = Math.max(a2, b1)
                    Right[0] = Math.min(a1, b2)
                } else {
                    Left[0] = Math.max(a2, b2)
                    Right[0] = Math.min(a1, b1)
                }
            }
            return Left[0] < Right[0]
        }

        private fun isParam1RightOfParam2(outRec1: OutRec?, outRec2: OutRec): Boolean {
            var outRec1 = outRec1
            do {
                outRec1 = outRec1!!.firstLeft
                if (outRec1 === outRec2) {
                    return true
                }
            } while (outRec1 != null)
            return false
        }

        //See "The Point in Polygon Problem for Arbitrary Polygons" by Hormann & Agathos
        //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf
        private fun isPointInPolygon(pt: LongPoint, op: Path.OutPt): Int {
            var op = op
            //returns 0 if false, +1 if true, -1 if pt ON polygon boundary
            var result = 0
            val startOp = op
            val ptx = pt.x
            val pty = pt.y
            var poly0x = op.pt.x
            var poly0y = op.pt.y
            do {
                op = op.next
                val poly1x = op.pt.x
                val poly1y = op.pt.y

                if (poly1y == pty) {
                    if (poly1x == ptx || poly0y == pty && poly1x > ptx == poly0x < ptx) {
                        return -1
                    }
                }
                if (poly0y < pty != poly1y < pty) {
                    if (poly0x >= ptx) {
                        if (poly1x > ptx) {
                            result = 1 - result
                        } else {
                            val d = (poly0x - ptx).toDouble() * (poly1y - pty) - (poly1x - ptx).toDouble() * (poly0y - pty)
                            if (d == 0.0) {
                                return -1
                            }
                            if (d > 0 == poly1y > poly0y) {
                                result = 1 - result
                            }
                        }
                    } else {
                        if (poly1x > ptx) {
                            val d = (poly0x - ptx).toDouble() * (poly1y - pty) - (poly1x - ptx).toDouble() * (poly0y - pty)
                            if (d == 0.0) {
                                return -1
                            }
                            if (d > 0 == poly1y > poly0y) {
                                result = 1 - result
                            }
                        }
                    }
                }
                poly0x = poly1x
                poly0y = poly1y
            } while (startOp !== op)

            return result
        }

        //------------------------------------------------------------------------------
        private fun joinHorz(op1: Path.OutPt, op1b: Path.OutPt, op2: Path.OutPt, op2b: Path.OutPt, Pt: LongPoint, DiscardLeft: Boolean): Boolean {
            var op1 = op1
            var op1b = op1b
            var op2 = op2
            var op2b = op2b
            val Dir1 = if (op1.pt.x > op1b.pt.x) Clipper.Direction.RIGHT_TO_LEFT else Clipper.Direction.LEFT_TO_RIGHT
            val Dir2 = if (op2.pt.x > op2b.pt.x) Clipper.Direction.RIGHT_TO_LEFT else Clipper.Direction.LEFT_TO_RIGHT
            if (Dir1 == Dir2) {
                return false
            }

            //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we
            //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)
            //So, to facilitate this while inserting Op1b and Op2b ...
            //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,
            //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)
            if (Dir1 == Clipper.Direction.LEFT_TO_RIGHT) {
                while (op1.next.pt.x <= Pt.x && op1.next.pt.x >= op1.pt.x && op1.next.pt.y == Pt.y) {
                    op1 = op1.next
                }
                if (DiscardLeft && op1.pt.x != Pt.x) {
                    op1 = op1.next
                }
                op1b = op1.duplicate(!DiscardLeft)
                if (op1b.pt != Pt) {
                    op1 = op1b
                    op1.pt = Pt
                    op1b = op1.duplicate(!DiscardLeft)
                }
            } else {
                while (op1.next.pt.x >= Pt.x && op1.next.pt.x <= op1.pt.x && op1.next.pt.y == Pt.y) {
                    op1 = op1.next
                }
                if (!DiscardLeft && op1.pt.x != Pt.x) {
                    op1 = op1.next
                }
                op1b = op1.duplicate(DiscardLeft)
                if (op1b.pt != Pt) {
                    op1 = op1b
                    op1.pt = Pt
                    op1b = op1.duplicate(DiscardLeft)
                }
            }

            if (Dir2 == Clipper.Direction.LEFT_TO_RIGHT) {
                while (op2.next.pt.x <= Pt.x && op2.next.pt.x >= op2.pt.x && op2.next.pt.y == Pt.y) {
                    op2 = op2.next
                }
                if (DiscardLeft && op2.pt.x != Pt.x) {
                    op2 = op2.next
                }
                op2b = op2.duplicate(!DiscardLeft)
                if (op2b.pt != Pt) {
                    op2 = op2b
                    op2.pt = Pt
                    op2b = op2.duplicate(!DiscardLeft)
                }
            } else {
                while (op2.next.pt.x >= Pt.x && op2.next.pt.x <= op2.pt.x && op2.next.pt.y == Pt.y) {
                    op2 = op2.next
                }
                if (!DiscardLeft && op2.pt.x != Pt.x) {
                    op2 = op2.next
                }
                op2b = op2.duplicate(DiscardLeft)
                if (op2b.pt != Pt) {
                    op2 = op2b
                    op2.pt = Pt
                    op2b = op2.duplicate(DiscardLeft)
                }
            }

            if (Dir1 == Clipper.Direction.LEFT_TO_RIGHT == DiscardLeft) {
                op1.prev = op2
                op2.next = op1
                op1b.next = op2b
                op2b.prev = op1b
            } else {
                op1.next = op2
                op2.prev = op1
                op1b.prev = op2b
                op2b.next = op1b
            }
            return true
        }

        private fun minkowski(pattern: Path, path: Path, IsSum: Boolean, IsClosed: Boolean): Paths {
            val delta = if (IsClosed) 1 else 0
            val polyCnt = pattern.size
            val pathCnt = path.size
            val result = Paths(pathCnt)
            if (IsSum) {
                for (i in 0..pathCnt - 1) {
                    val p = Path(polyCnt)
                    for (ip in pattern) {
                        p.add(LongPoint(path[i].x + ip.x, path[i].y + ip.y, 0))
                    }
                    result.add(p)
                }
            } else {
                for (i in 0..pathCnt - 1) {
                    val p = Path(polyCnt)
                    for (ip in pattern) {
                        p.add(LongPoint(path[i].x - ip.x, path[i].y - ip.y, 0))
                    }
                    result.add(p)
                }
            }

            val quads = Paths((pathCnt + delta) * (polyCnt + 1))
            for (i in 0..pathCnt - 1 + delta - 1) {
                for (j in 0..polyCnt - 1) {
                    val quad = Path(4)
                    quad.add(result[i % pathCnt][j % polyCnt])
                    quad.add(result[(i + 1) % pathCnt][j % polyCnt])
                    quad.add(result[(i + 1) % pathCnt][(j + 1) % polyCnt])
                    quad.add(result[i % pathCnt][(j + 1) % polyCnt])
                    if (!quad.orientation()) {
                        Collections.reverse(quad)
                    }
                    quads.add(quad)
                }
            }
            return quads
        }

        fun minkowskiDiff(poly1: Path, poly2: Path): Paths {
            val paths = minkowski(poly1, poly2, false, true)
            val c = DefaultClipper()
            c.addPaths(paths, Clipper.PolyType.SUBJECT, true)
            c.execute(Clipper.ClipType.UNION, paths, Clipper.PolyFillType.NON_ZERO, Clipper.PolyFillType.NON_ZERO)
            return paths
        }

        fun minkowskiSum(pattern: Path, path: Path, pathIsClosed: Boolean): Paths {
            val paths = minkowski(pattern, path, true, pathIsClosed)
            val c = DefaultClipper()
            c.addPaths(paths, Clipper.PolyType.SUBJECT, true)
            c.execute(Clipper.ClipType.UNION, paths, Clipper.PolyFillType.NON_ZERO, Clipper.PolyFillType.NON_ZERO)
            return paths
        }

        fun minkowskiSum(pattern: Path, paths: Paths, pathIsClosed: Boolean): Paths {
            val solution = Paths()
            val c = DefaultClipper()
            for (i in paths.indices) {
                val tmp = minkowski(pattern, paths[i], true, pathIsClosed)
                c.addPaths(tmp, Clipper.PolyType.SUBJECT, true)
                if (pathIsClosed) {
                    val path = paths[i].TranslatePath(pattern[0])
                    c.addPath(path, Clipper.PolyType.CLIP, true)
                }
            }
            c.execute(Clipper.ClipType.UNION, solution, Clipper.PolyFillType.NON_ZERO, Clipper.PolyFillType.NON_ZERO)
            return solution
        }

        private fun poly2ContainsPoly1(outPt1: Path.OutPt, outPt2: Path.OutPt): Boolean {
            var op = outPt1
            do {
                //nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon
                val res = isPointInPolygon(op.pt, outPt2)
                if (res >= 0) {
                    return res > 0
                }
                op = op.next
            } while (op !== outPt1)
            return true
        }

        @JvmOverloads fun simplifyPolygon(poly: Path, fillType: Clipper.PolyFillType = Clipper.PolyFillType.EVEN_ODD): Paths {
            val result = Paths()
            val c = DefaultClipper(Clipper.STRICTLY_SIMPLE)

            c.addPath(poly, Clipper.PolyType.SUBJECT, true)
            c.execute(Clipper.ClipType.UNION, result, fillType, fillType)
            return result
        }

        @JvmOverloads fun simplifyPolygons(polys: Paths, fillType: Clipper.PolyFillType = Clipper.PolyFillType.EVEN_ODD): Paths {
            val result = Paths()
            val c = DefaultClipper(Clipper.STRICTLY_SIMPLE)

            c.addPaths(polys, Clipper.PolyType.SUBJECT, true)
            c.execute(Clipper.ClipType.UNION, result, fillType, fillType)
            return result
        }

        private val LOGGER = Logger.getLogger(DefaultClipper::class.java.name)
    }

}//------------------------------------------------------------------------------
// SimplifyPolygon functions ...
// Convert self-intersecting polygons into simple polygons
//------------------------------------------------------------------------------
//end Clipper

