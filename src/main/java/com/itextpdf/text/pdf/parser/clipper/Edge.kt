/*
 * $Id: dbafd1df04cabab3f8dd520f140f5928f57c6ab8 $
 *
 * This file is part of the iText (R) project.
 * Copyright (c) 2014-2015 iText Group NV
 * Authors: Bruno Lowagie, Paulo Soares, et al.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License version 3
 * as published by the Free Software Foundation with the addition of the
 * following permission added to Section 15 as permitted in Section 7(a):
 * FOR ANY PART OF THE COVERED WORK IN WHICH THE COPYRIGHT IS OWNED BY
 * ITEXT GROUP. ITEXT GROUP DISCLAIMS THE WARRANTY OF NON INFRINGEMENT
 * OF THIRD PARTY RIGHTS
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, see http://www.gnu.org/licenses or write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA, 02110-1301 USA, or download the license from the following URL:
 * http://itextpdf.com/terms-of-use/
 *
 * The interactive user interfaces in modified source and object code versions
 * of this program must display Appropriate Legal Notices, as required under
 * Section 5 of the GNU Affero General Public License.
 *
 * In accordance with Section 7(b) of the GNU Affero General Public License,
 * a covered work must retain the producer line in every PDF that is created
 * or manipulated using iText.
 *
 * You can be released from the requirements of the license by purchasing
 * a commercial license. Buying such a license is mandatory as soon as you
 * develop commercial activities involving the iText software without
 * disclosing the source code of your own applications.
 * These activities include: offering paid services to customers as an ASP,
 * serving PDFs on the fly in a web application, shipping iText with a closed
 * source product.
 *
 * For more information, please contact iText Software Corp. at this
 * address: sales@itextpdf.com
 *
 *
 * This class is based on the C# open source freeware library Clipper:
 * http://www.angusj.com/delphi/clipper.php
 * The original classes were distributed under the Boost Software License:
 *
 * Freeware for both open source and commercial applications
 * Copyright 2010-2014 Angus Johnson
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
package com.itextpdf.text.pdf.parser.clipper

import java.math.BigInteger
import java.util.logging.Logger

import com.itextpdf.text.pdf.parser.clipper.Clipper.ClipType
import com.itextpdf.text.pdf.parser.clipper.Clipper.Direction
import com.itextpdf.text.pdf.parser.clipper.Clipper.PolyFillType
import com.itextpdf.text.pdf.parser.clipper.Clipper.PolyType
import com.itextpdf.text.pdf.parser.clipper.Point.LongPoint

internal class Edge {
    internal enum class Side {
        LEFT, RIGHT
    }

    var bot: LongPoint
        set(bot) = this.bot.set(bot)

    var current: LongPoint
        set(current) = this.current.set(current)

    var top: LongPoint
        set(top) = this.top.set(top)

    val delta: LongPoint
    var deltaX: Double = 0.toDouble()

    var polyTyp: PolyType

    var side: Edge.Side

    var windDelta: Int = 0 //1 or -1 depending on winding direction

    var windCnt: Int = 0
    var windCnt2: Int = 0 //winding count of the opposite polytype
    var outIdx: Int = 0
    var next: Edge
    var prev: Edge
    var nextInLML: Edge? = null
    var nextInAEL: Edge
    var prevInAEL: Edge
    var nextInSEL: Edge
    var prevInSEL: Edge

    init {
        delta = LongPoint()
        top = LongPoint()
        bot = LongPoint()
        current = LongPoint()
    }

    fun findNextLocMin(): Edge {
        var e = this
        var e2: Edge
        while (true) {
            while (e.bot != e.prev.bot || e.current == e.top) {
                e = e.next
            }
            if (e.deltaX != Edge.HORIZONTAL && e.prev.deltaX != Edge.HORIZONTAL) {
                break
            }
            while (e.prev.deltaX == Edge.HORIZONTAL) {
                e = e.prev
            }
            e2 = e
            while (e.deltaX == Edge.HORIZONTAL) {
                e = e.next
            }
            if (e.top.y == e.prev.bot.y) {
                continue //ie just an intermediate horz.
            }
            if (e2.prev.bot.x < e.bot.x) {
                e = e2
            }
            break
        }
        return e
    }

    val maximaPair: Edge?
        get() {
            var result: Edge? = null
            if (next.top == top && next.nextInLML == null) {
                result = next
            } else if (prev.top == top && prev.nextInLML == null) {
                result = prev
            }
            if (result != null && (result.outIdx == Edge.SKIP || result.nextInAEL === result.prevInAEL && !result.isHorizontal)) {
                return null
            }
            return result
        }

    fun getNextInAEL(direction: Direction): Edge {
        return if (direction == Direction.LEFT_TO_RIGHT) nextInAEL else prevInAEL
    }

    fun isContributing(clipFillType: PolyFillType, subjFillType: PolyFillType, clipType: ClipType): Boolean {
        LOGGER.entering(Edge::class.java.name, "isContributing")

        val pft: PolyFillType
        val pft2: PolyFillType
        if (polyTyp == PolyType.SUBJECT) {
            pft = subjFillType
            pft2 = clipFillType
        } else {
            pft = clipFillType
            pft2 = subjFillType
        }

        when (pft) {
            Clipper.PolyFillType.EVEN_ODD -> //return false if a subj line has been flagged as inside a subj polygon
                if (windDelta == 0 && windCnt != 1) {
                    return false
                }
            Clipper.PolyFillType.NON_ZERO -> if (Math.abs(windCnt) != 1) {
                return false
            }
            Clipper.PolyFillType.POSITIVE -> if (windCnt != 1) {
                return false
            }
            else //PolyFillType.pftNegative
            -> if (windCnt != -1) {
                return false
            }
        }

        when (clipType) {
            Clipper.ClipType.INTERSECTION -> {
                when (pft2) {
                    Clipper.PolyFillType.EVEN_ODD, Clipper.PolyFillType.NON_ZERO -> return windCnt2 != 0
                    Clipper.PolyFillType.POSITIVE -> return windCnt2 > 0
                    else -> return windCnt2 < 0
                }
                when (pft2) {
                    Clipper.PolyFillType.EVEN_ODD, Clipper.PolyFillType.NON_ZERO -> return windCnt2 == 0
                    Clipper.PolyFillType.POSITIVE -> return windCnt2 <= 0
                    else -> return windCnt2 >= 0
                }
                if (polyTyp == PolyType.SUBJECT) {
                    when (pft2) {
                        Clipper.PolyFillType.EVEN_ODD, Clipper.PolyFillType.NON_ZERO -> return windCnt2 == 0
                        Clipper.PolyFillType.POSITIVE -> return windCnt2 <= 0
                        else -> return windCnt2 >= 0
                    }
                } else {
                    when (pft2) {
                        Clipper.PolyFillType.EVEN_ODD, Clipper.PolyFillType.NON_ZERO -> return windCnt2 != 0
                        Clipper.PolyFillType.POSITIVE -> return windCnt2 > 0
                        else -> return windCnt2 < 0
                    }
                }
                if (windDelta == 0) {
                    when (pft2) {
                        Clipper.PolyFillType.EVEN_ODD, Clipper.PolyFillType.NON_ZERO -> return windCnt2 == 0
                        Clipper.PolyFillType.POSITIVE -> return windCnt2 <= 0
                        else -> return windCnt2 >= 0
                    }
                } else {
                    return true
                }
            }
            Clipper.ClipType.UNION -> {
                when (pft2) {
                    Clipper.PolyFillType.EVEN_ODD, Clipper.PolyFillType.NON_ZERO -> return windCnt2 == 0
                    Clipper.PolyFillType.POSITIVE -> return windCnt2 <= 0
                    else -> return windCnt2 >= 0
                }
                if (polyTyp == PolyType.SUBJECT) {
                    when (pft2) {
                        Clipper.PolyFillType.EVEN_ODD, Clipper.PolyFillType.NON_ZERO -> return windCnt2 == 0
                        Clipper.PolyFillType.POSITIVE -> return windCnt2 <= 0
                        else -> return windCnt2 >= 0
                    }
                } else {
                    when (pft2) {
                        Clipper.PolyFillType.EVEN_ODD, Clipper.PolyFillType.NON_ZERO -> return windCnt2 != 0
                        Clipper.PolyFillType.POSITIVE -> return windCnt2 > 0
                        else -> return windCnt2 < 0
                    }
                }
                if (windDelta == 0) {
                    when (pft2) {
                        Clipper.PolyFillType.EVEN_ODD, Clipper.PolyFillType.NON_ZERO -> return windCnt2 == 0
                        Clipper.PolyFillType.POSITIVE -> return windCnt2 <= 0
                        else -> return windCnt2 >= 0
                    }
                } else {
                    return true
                }
            }
            Clipper.ClipType.DIFFERENCE -> {
                if (polyTyp == PolyType.SUBJECT) {
                    when (pft2) {
                        Clipper.PolyFillType.EVEN_ODD, Clipper.PolyFillType.NON_ZERO -> return windCnt2 == 0
                        Clipper.PolyFillType.POSITIVE -> return windCnt2 <= 0
                        else -> return windCnt2 >= 0
                    }
                } else {
                    when (pft2) {
                        Clipper.PolyFillType.EVEN_ODD, Clipper.PolyFillType.NON_ZERO -> return windCnt2 != 0
                        Clipper.PolyFillType.POSITIVE -> return windCnt2 > 0
                        else -> return windCnt2 < 0
                    }
                }
                if (windDelta == 0) {
                    when (pft2) {
                        Clipper.PolyFillType.EVEN_ODD, Clipper.PolyFillType.NON_ZERO -> return windCnt2 == 0
                        Clipper.PolyFillType.POSITIVE -> return windCnt2 <= 0
                        else -> return windCnt2 >= 0
                    }
                } else {
                    return true
                }
            }
            Clipper.ClipType.XOR -> if (windDelta == 0) {
                when (pft2) {
                    Clipper.PolyFillType.EVEN_ODD, Clipper.PolyFillType.NON_ZERO -> return windCnt2 == 0
                    Clipper.PolyFillType.POSITIVE -> return windCnt2 <= 0
                    else -> return windCnt2 >= 0
                }
            } else {
                return true
            }
        }
        return true
    }

    fun isEvenOddAltFillType(clipFillType: PolyFillType, subjFillType: PolyFillType): Boolean {
        if (polyTyp == PolyType.SUBJECT) {
            return clipFillType == PolyFillType.EVEN_ODD
        } else {
            return subjFillType == PolyFillType.EVEN_ODD
        }
    }

    fun isEvenOddFillType(clipFillType: PolyFillType, subjFillType: PolyFillType): Boolean {
        if (polyTyp == PolyType.SUBJECT) {
            return subjFillType == PolyFillType.EVEN_ODD
        } else {
            return clipFillType == PolyFillType.EVEN_ODD
        }
    }

    val isHorizontal: Boolean
        get() = delta.y == 0

    fun isIntermediate(y: Double): Boolean {
        return top.y.toDouble() == y && nextInLML != null
    }

    fun isMaxima(Y: Double): Boolean {
        return top.y.toDouble() == Y && nextInLML == null
    }

    fun reverseHorizontal() {
        //swap horizontal edges' top and bottom x's so they follow the natural
        //progression of the bounds - ie so their xbots will align with the
        //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]
        var temp = top.x
        top.setX(bot.x)
        bot.setX(temp)

        temp = top.z
        top.setZ(bot.z)
        bot.setZ(temp)

    }

    override fun toString(): String {
        return "TEdge [Bot=$bot, Curr=$current, Top=$top, Delta=$delta, Dx=$deltaX, PolyTyp=$polyTyp, Side=$side"
        +", WindDelta=" + windDelta + ", WindCnt=" + windCnt + ", WindCnt2=" + windCnt2 + ", OutIdx=" + outIdx + ", Next=" + next + ", Prev="
        +prev + ", NextInLML=" + nextInLML + ", NextInAEL=" + nextInAEL + ", PrevInAEL=" + prevInAEL + ", NextInSEL=" + nextInSEL
        +", PrevInSEL=" + prevInSEL + "]"
    }

    fun updateDeltaX() {

        delta.setX(top.x - bot.x)
        delta.setY(top.y - bot.y)
        if (delta.y == 0) {
            deltaX = Edge.HORIZONTAL
        } else {
            deltaX = delta.x.toDouble() / delta.y
        }
    }

    companion object {

        fun doesE2InsertBeforeE1(e1: Edge, e2: Edge): Boolean {
            if (e2.current.x == e1.current.x) {
                if (e2.top.y > e1.top.y) {
                    return e2.top.x < topX(e1, e2.top.y)
                } else {
                    return e1.top.x > topX(e2, e1.top.y)
                }
            } else {
                return e2.current.x < e1.current.x
            }
        }

        fun slopesEqual(e1: Edge, e2: Edge, useFullRange: Boolean): Boolean {
            if (useFullRange) {
                return BigInteger.valueOf(e1.delta.y).multiply(BigInteger.valueOf(e2.delta.x)) == BigInteger.valueOf(e1.delta.x).multiply(BigInteger.valueOf(e2.delta.y))
            } else {
                return e1.delta.y * e2.delta.x == e1.delta.x * e2.delta.y
            }
        }

        fun swapPolyIndexes(edge1: Edge, edge2: Edge) {
            val outIdx = edge1.outIdx
            edge1.outIdx = edge2.outIdx
            edge2.outIdx = outIdx
        }

        fun swapSides(edge1: Edge, edge2: Edge) {
            val side = edge1.side
            edge1.side = edge2.side
            edge2.side = side
        }

        fun topX(edge: Edge, currentY: Long): Long {
            if (currentY == edge.top.y) {
                return edge.top.x
            }
            return edge.bot.x + Math.round(edge.deltaX * (currentY - edge.bot.y))
        }

        protected val SKIP = -2

        protected val UNASSIGNED = -1

        protected val HORIZONTAL = -3.4E+38

        private val LOGGER = Logger.getLogger(Edge::class.java.name)
    }

}
