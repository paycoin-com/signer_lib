/*
 * $Id: 3b6230f569d58d08e776fcbb791145b0709a551a $
 *
 * This file is part of the iText (R) project.
 * Copyright (c) 2014-2015 iText Group NV
 * Authors: Bruno Lowagie, Paulo Soares, et al.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License version 3
 * as published by the Free Software Foundation with the addition of the
 * following permission added to Section 15 as permitted in Section 7(a):
 * FOR ANY PART OF THE COVERED WORK IN WHICH THE COPYRIGHT IS OWNED BY
 * ITEXT GROUP. ITEXT GROUP DISCLAIMS THE WARRANTY OF NON INFRINGEMENT
 * OF THIRD PARTY RIGHTS
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, see http://www.gnu.org/licenses or write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA, 02110-1301 USA, or download the license from the following URL:
 * http://itextpdf.com/terms-of-use/
 *
 * The interactive user interfaces in modified source and object code versions
 * of this program must display Appropriate Legal Notices, as required under
 * Section 5 of the GNU Affero General Public License.
 *
 * In accordance with Section 7(b) of the GNU Affero General Public License,
 * a covered work must retain the producer line in every PDF that is created
 * or manipulated using iText.
 *
 * You can be released from the requirements of the license by purchasing
 * a commercial license. Buying such a license is mandatory as soon as you
 * develop commercial activities involving the iText software without
 * disclosing the source code of your own applications.
 * These activities include: offering paid services to customers as an ASP,
 * serving PDFs on the fly in a web application, shipping iText with a closed
 * source product.
 *
 * For more information, please contact iText Software Corp. at this
 * address: sales@itextpdf.com
 *
 *
 * This class is based on the C# open source freeware library Clipper:
 * http://www.angusj.com/delphi/clipper.php
 * The original classes were distributed under the Boost Software License:
 *
 * Freeware for both open source and commercial applications
 * Copyright 2010-2014 Angus Johnson
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
package com.itextpdf.text.pdf.parser.clipper

import com.itextpdf.text.pdf.parser.clipper.Point.LongPoint

import java.util.ArrayList
import java.util.logging.Logger

abstract class ClipperBase protected constructor(val isPreserveCollinear: Boolean //constructor (nb: no external instantiation)
) : Clipper {
    protected inner class LocalMinima {
        internal var y: Long = 0
        internal var leftBound: Edge? = null
        internal var rightBound: Edge? = null
        internal var next: LocalMinima? = null
    }

    protected inner class Scanbeam {
        internal var y: Long = 0
        internal var next: Scanbeam
    }

    protected var minimaList: LocalMinima? = null

    protected var currentLM: LocalMinima? = null

    private val edges: MutableList<List<Edge>>

    protected var useFullRange: Boolean = false

    protected var hasOpenPaths: Boolean = false

    init {
        minimaList = null
        currentLM = null
        hasOpenPaths = false
        edges = ArrayList<List<Edge>>()
    }

    override fun addPath(pg: Path, polyType: Clipper.PolyType, Closed: Boolean): Boolean {

        if (!Closed && polyType == Clipper.PolyType.CLIP) {
            throw IllegalStateException("AddPath: Open paths must be subject.")
        }

        var highI = pg.size - 1
        if (Closed) {
            while (highI > 0 && pg[highI] == pg[0]) {
                --highI
            }
        }
        while (highI > 0 && pg[highI] == pg[highI - 1]) {
            --highI
        }
        if (Closed && highI < 2 || !Closed && highI < 1) {
            return false
        }

        //create a new edge array ...
        val edges = ArrayList<Edge>(highI + 1)
        for (i in 0..highI) {
            edges.add(Edge())
        }

        var IsFlat = true

        //1. Basic (first) edge initialization ...
        edges[1].current = LongPoint(pg[1])
        useFullRange = rangeTest(pg[0], useFullRange)
        useFullRange = rangeTest(pg[highI], useFullRange)
        initEdge(edges[0], edges[1], edges[highI], pg[0])
        initEdge(edges[highI], edges[0], edges[highI - 1], pg[highI])
        for (i in highI - 1 downTo 1) {
            useFullRange = rangeTest(pg[i], useFullRange)
            initEdge(edges[i], edges[i + 1], edges[i - 1], pg[i])
        }
        var eStart = edges[0]

        //2. Remove duplicate vertices, and (when closed) collinear edges ...
        var e = eStart
        var eLoopStop = eStart
        while (true) {
            //nb: allows matching start and end points when not Closed ...
            if (e.current == e.next.current && (Closed || e.next != eStart)) {
                if (e === e.next) {
                    break
                }
                if (e === eStart) {
                    eStart = e.next
                }
                e = removeEdge(e)
                eLoopStop = e
                continue
            }
            if (e.prev === e.next) {
                break //only two vertices
            } else if (Closed && Point.slopesEqual(e.prev.current, e.current, e.next.current, useFullRange)
                    && (!isPreserveCollinear || !Point.isPt2BetweenPt1AndPt3(e.prev.current, e.current, e.next.current))) {
                //Collinear edges are allowed for open paths but in closed paths
                //the default is to merge adjacent collinear edges into a single edge.
                //However, if the PreserveCollinear property is enabled, only overlapping
                //collinear edges (ie spikes) will be removed from closed paths.
                if (e === eStart) {
                    eStart = e.next
                }
                e = removeEdge(e)
                e = e.prev
                eLoopStop = e
                continue
            }
            e = e.next
            if (e === eLoopStop || !Closed && e.next === eStart) {
                break
            }
        }

        if (!Closed && e === e.next || Closed && e.prev === e.next) {
            return false
        }

        if (!Closed) {
            hasOpenPaths = true
            eStart.prev.outIdx = Edge.SKIP
        }

        //3. Do second stage of edge initialization ...
        e = eStart
        do {
            initEdge2(e, polyType)
            e = e.next
            if (IsFlat && e.current.y != eStart.current.y) {
                IsFlat = false
            }
        } while (e !== eStart)

        //4. Finally, add edge bounds to LocalMinima list ...

        //Totally flat paths must be handled differently when adding them
        //to LocalMinima list to avoid endless loops etc ...
        if (IsFlat) {
            if (Closed) {
                return false
            }
            e.prev.outIdx = Edge.SKIP
            val locMin = LocalMinima()
            locMin.next = null
            locMin.y = e.bot.y
            locMin.leftBound = null
            locMin.rightBound = e
            locMin.rightBound!!.side = Edge.Side.RIGHT
            locMin.rightBound!!.windDelta = 0
            while (true) {
                if (e.bot.x != e.prev.top.x) e.reverseHorizontal()
                if (e.next.outIdx == Edge.SKIP) break
                e.nextInLML = e.next
                e = e.next
            }
            insertLocalMinima(locMin)
            this.edges.add(edges)
            return true
        }

        this.edges.add(edges)
        var leftBoundIsForward: Boolean
        var EMin: Edge? = null

        //workaround to avoid an endless loop in the while loop below when
        //open paths have matching start and end points ...
        if (e.prev.bot == e.prev.top) {
            e = e.next
        }

        while (true) {
            e = e.findNextLocMin()
            if (e === EMin) {
                break
            } else if (EMin == null) {
                EMin = e
            }

            //E and E.Prev now share a local minima (left aligned if horizontal).
            //Compare their slopes to find which starts which bound ...
            val locMin = LocalMinima()
            locMin.next = null
            locMin.y = e.bot.y
            if (e.deltaX < e.prev.deltaX) {
                locMin.leftBound = e.prev
                locMin.rightBound = e
                leftBoundIsForward = false //Q.nextInLML = Q.prev
            } else {
                locMin.leftBound = e
                locMin.rightBound = e.prev
                leftBoundIsForward = true //Q.nextInLML = Q.next
            }
            locMin.leftBound!!.side = Edge.Side.LEFT
            locMin.rightBound!!.side = Edge.Side.RIGHT

            if (!Closed) {
                locMin.leftBound!!.windDelta = 0
            } else if (locMin.leftBound!!.next === locMin.rightBound) {
                locMin.leftBound!!.windDelta = -1
            } else {
                locMin.leftBound!!.windDelta = 1
            }
            locMin.rightBound!!.windDelta = -locMin.leftBound!!.windDelta

            e = processBound(locMin.leftBound, leftBoundIsForward)
            if (e.outIdx == Edge.SKIP) {
                e = processBound(e, leftBoundIsForward)
            }

            var E2 = processBound(locMin.rightBound, !leftBoundIsForward)
            if (E2.outIdx == Edge.SKIP) {
                E2 = processBound(E2, !leftBoundIsForward)
            }

            if (locMin.leftBound!!.outIdx == Edge.SKIP) {
                locMin.leftBound = null
            } else if (locMin.rightBound!!.outIdx == Edge.SKIP) {
                locMin.rightBound = null
            }
            insertLocalMinima(locMin)
            if (!leftBoundIsForward) {
                e = E2
            }
        }
        return true

    }

    override fun addPaths(ppg: Paths, polyType: Clipper.PolyType, closed: Boolean): Boolean {
        var result = false
        for (i in ppg.indices) {
            if (addPath(ppg[i], polyType, closed)) {
                result = true
            }
        }
        return result
    }

    override fun clear() {
        disposeLocalMinimaList()
        edges.clear()
        useFullRange = false
        hasOpenPaths = false
    }

    private fun disposeLocalMinimaList() {
        while (minimaList != null) {
            val tmpLm = minimaList!!.next
            minimaList = null
            minimaList = tmpLm
        }
        currentLM = null
    }

    private fun insertLocalMinima(newLm: LocalMinima) {
        if (minimaList == null) {
            minimaList = newLm
        } else if (newLm.y >= minimaList!!.y) {
            newLm.next = minimaList
            minimaList = newLm
        } else {
            var tmpLm: LocalMinima = minimaList
            while (tmpLm.next != null && newLm.y < tmpLm.next!!.y) {
                tmpLm = tmpLm.next
            }
            newLm.next = tmpLm.next
            tmpLm.next = newLm
        }
    }

    protected fun popLocalMinima() {
        LOGGER.entering(ClipperBase::class.java.name, "popLocalMinima")
        if (currentLM == null) {
            return
        }
        currentLM = currentLM!!.next
    }

    private fun processBound(e: Edge, LeftBoundIsForward: Boolean): Edge {
        var e = e
        var EStart: Edge
        var result = e
        var Horz: Edge

        if (result.outIdx == Edge.SKIP) {
            //check if there are edges beyond the skip edge in the bound and if so
            //create another LocMin and calling ProcessBound once more ...
            e = result
            if (LeftBoundIsForward) {
                while (e.top.y == e.next.bot.y) {
                    e = e.next
                }
                while (e !== result && e.deltaX == Edge.HORIZONTAL) {
                    e = e.prev
                }
            } else {
                while (e.top.y == e.prev.bot.y) {
                    e = e.prev
                }
                while (e !== result && e.deltaX == Edge.HORIZONTAL) {
                    e = e.next
                }
            }
            if (e === result) {
                if (LeftBoundIsForward) {
                    result = e.next
                } else {
                    result = e.prev
                }
            } else {
                //there are more edges in the bound beyond result starting with E
                if (LeftBoundIsForward) {
                    e = result.next
                } else {
                    e = result.prev
                }
                val locMin = LocalMinima()
                locMin.next = null
                locMin.y = e.bot.y
                locMin.leftBound = null
                locMin.rightBound = e
                e.windDelta = 0
                result = processBound(e, LeftBoundIsForward)
                insertLocalMinima(locMin)
            }
            return result
        }

        if (e.deltaX == Edge.HORIZONTAL) {
            //We need to be careful with open paths because this may not be a
            //true local minima (ie E may be following a skip edge).
            //Also, consecutive horz. edges may start heading left before going right.
            if (LeftBoundIsForward) {
                EStart = e.prev
            } else {
                EStart = e.next
            }
            if (EStart.deltaX == Edge.HORIZONTAL)
            //ie an adjoining horizontal skip edge
            {
                if (EStart.bot.x != e.bot.x && EStart.top.x != e.bot.x)
                    e.reverseHorizontal()
            } else if (EStart.bot.x != e.bot.x)
                e.reverseHorizontal()
        }

        EStart = e
        if (LeftBoundIsForward) {
            while (result.top.y == result.next.bot.y && result.next.outIdx != Edge.SKIP) {
                result = result.next
            }
            if (result.deltaX == Edge.HORIZONTAL && result.next.outIdx != Edge.SKIP) {
                //nb: at the top of a bound, horizontals are added to the bound
                //only when the preceding edge attaches to the horizontal's left vertex
                //unless a Skip edge is encountered when that becomes the top divide
                Horz = result
                while (Horz.prev.deltaX == Edge.HORIZONTAL) {
                    Horz = Horz.prev
                }
                if (Horz.prev.top.x > result.next.top.x) result = Horz.prev
            }
            while (e !== result) {
                e.nextInLML = e.next
                if (e.deltaX == Edge.HORIZONTAL && e !== EStart && e.bot.x != e.prev.top.x) {
                    e.reverseHorizontal()
                }
                e = e.next
            }
            if (e.deltaX == Edge.HORIZONTAL && e !== EStart && e.bot.x != e.prev.top.x) {
                e.reverseHorizontal()
            }
            result = result.next //move to the edge just beyond current bound
        } else {
            while (result.top.y == result.prev.bot.y && result.prev.outIdx != Edge.SKIP) {
                result = result.prev
            }
            if (result.deltaX == Edge.HORIZONTAL && result.prev.outIdx != Edge.SKIP) {
                Horz = result
                while (Horz.next.deltaX == Edge.HORIZONTAL) {
                    Horz = Horz.next
                }
                if (Horz.next.top.x == result.prev.top.x || Horz.next.top.x > result.prev.top.x)
                    result = Horz.next
            }

            while (e !== result) {
                e.nextInLML = e.prev
                if (e.deltaX == Edge.HORIZONTAL && e !== EStart && e.bot.x != e.next.top.x) {
                    e.reverseHorizontal()
                }
                e = e.prev
            }
            if (e.deltaX == Edge.HORIZONTAL && e !== EStart && e.bot.x != e.next.top.x) {
                e.reverseHorizontal()
            }
            result = result.prev //move to the edge just beyond current bound
        }
        return result
    }

    protected open fun reset() {
        currentLM = minimaList
        if (currentLM == null) {
            return  //ie nothing to process
        }

        //reset all edges ...
        var lm = minimaList
        while (lm != null) {
            var e = lm.leftBound
            if (e != null) {
                e.current = LongPoint(e.bot)
                e.side = Edge.Side.LEFT
                e.outIdx = Edge.UNASSIGNED
            }
            e = lm.rightBound
            if (e != null) {
                e.current = LongPoint(e.bot)
                e.side = Edge.Side.RIGHT
                e.outIdx = Edge.UNASSIGNED
            }
            lm = lm.next
        }
    }

    companion object {

        private fun initEdge(e: Edge, eNext: Edge, ePrev: Edge, pt: LongPoint) {
            e.next = eNext
            e.prev = ePrev
            e.current = LongPoint(pt)
            e.outIdx = Edge.UNASSIGNED
        }

        private fun initEdge2(e: Edge, polyType: Clipper.PolyType) {
            if (e.current.y >= e.next.current.y) {
                e.bot = LongPoint(e.current)
                e.top = LongPoint(e.next.current)
            } else {
                e.top = LongPoint(e.current)
                e.bot = LongPoint(e.next.current)
            }
            e.updateDeltaX()
            e.polyTyp = polyType
        }

        private fun rangeTest(Pt: LongPoint, useFullRange: Boolean): Boolean {
            if (useFullRange) {
                if (Pt.x > HI_RANGE || Pt.y > HI_RANGE || -Pt.x > HI_RANGE || -Pt.y > HI_RANGE)
                    throw IllegalStateException("Coordinate outside allowed range")
            } else if (Pt.x > LOW_RANGE || Pt.y > LOW_RANGE || -Pt.x > LOW_RANGE || -Pt.y > LOW_RANGE) {
                return rangeTest(Pt, true)
            }

            return useFullRange
        }

        private fun removeEdge(e: Edge): Edge {
            //removes e from double_linked_list (but without removing from memory)
            e.prev.next = e.next
            e.next.prev = e.prev
            val result = e.next
            e.prev = null //flag as removed (see ClipperBase.Clear)
            return result
        }

        private val LOW_RANGE: Long = 0x3FFFFFFF

        private val HI_RANGE = 0x3FFFFFFFFFFFFFFFL

        private val LOGGER = Logger.getLogger(Clipper::class.java.name)

        protected fun parseFirstLeft(FirstLeft: Path.OutRec?): Path.OutRec {
            var FirstLeft = FirstLeft
            while (FirstLeft != null && FirstLeft.points == null)
                FirstLeft = FirstLeft.firstLeft
            return FirstLeft
        }
    }

}